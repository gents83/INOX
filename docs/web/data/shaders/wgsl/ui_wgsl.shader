{"spirv_code":[],"wgsl_code":"let MAX_TEXTURE_ATLAS_COUNT: u32 = 16u;\r\nlet MAX_NUM_LIGHTS: u32 = 64u;\r\nlet MAX_NUM_TEXTURES: u32 = 512u;\r\nlet MAX_NUM_MATERIALS: u32 = 512u;\r\n\r\nlet TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\r\nlet TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\r\nlet TEXTURE_TYPE_NORMAL: u32 = 2u;\r\nlet TEXTURE_TYPE_EMISSIVE: u32 = 3u;\r\nlet TEXTURE_TYPE_OCCLUSION: u32 = 4u;\r\nlet TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\r\nlet TEXTURE_TYPE_DIFFUSE: u32 = 6u;\r\nlet TEXTURE_TYPE_EMPTY_FOR_PADDING: u32 = 7u;\r\nlet TEXTURE_TYPE_COUNT: u32 = 8u;\r\n\r\nlet CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\r\nlet CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\r\n\r\nstruct ConstantData {\r\n    view: mat4x4<f32>,\r\n    proj: mat4x4<f32>,\r\n    screen_width: f32,\r\n    screen_height: f32,\r\n    flags: u32,\r\n};\r\n\r\nstruct LightData {\r\n    position: vec3<f32>,\r\n    light_type: u32,\r\n    color: vec4<f32>,\r\n    intensity: f32,\r\n    range: f32,\r\n    inner_cone_angle: f32,\r\n    outer_cone_angle: f32,\r\n};\r\n\r\nstruct TextureData {\r\n    texture_index: u32,\r\n    layer_index: u32,\r\n    total_width: f32,\r\n    total_height: f32,\r\n    area: vec4<f32>,\r\n};\r\n\r\nstruct ShaderMaterialData {\r\n    textures_indices: array<i32, 8>,//TEXTURE_TYPE_COUNT>,\r\n    textures_coord_set: array<u32, 8>,//TEXTURE_TYPE_COUNT>,\r\n    roughness_factor: f32,\r\n    metallic_factor: f32,\r\n    alpha_cutoff: f32,\r\n    alpha_mode: u32,\r\n    base_color: vec4<f32>,\r\n    emissive_color: vec4<f32>,\r\n    diffuse_color: vec4<f32>,\r\n    specular_color: vec4<f32>,\r\n};\r\n\r\nstruct DynamicData {\r\n    textures_data: array<TextureData, 512>,//MAX_NUM_TEXTURES>,\r\n    materials_data: array<ShaderMaterialData, 512>,//MAX_NUM_MATERIALS>,\r\n    lights_data: array<LightData, 64>,//MAX_NUM_LIGHTS>,\r\n};\r\n\r\nstruct UIData {\r\n    scale: f32,\r\n};\r\n\r\nstruct VertexInput {\r\n    //@builtin(vertex_index) index: u32,\r\n    @location(0) position: vec3<f32>,\r\n    @location(1) tex_coords_0: vec2<f32>,\r\n    @location(2) color: u32,\r\n};\r\n\r\nstruct InstanceInput {\r\n    //@builtin(instance_index) index: u32,\r\n    @location(3) draw_area: vec4<f32>,\r\n    @location(4) model_matrix_0: vec4<f32>,\r\n    @location(5) model_matrix_1: vec4<f32>,\r\n    @location(6) model_matrix_2: vec4<f32>,\r\n    @location(7) model_matrix_3: vec4<f32>,\r\n    @location(8) normal_matrix_0: vec3<f32>,\r\n    @location(9) normal_matrix_1: vec3<f32>,\r\n    @location(10) normal_matrix_2: vec3<f32>,\r\n    @location(11) material_index: i32,\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) clip_position: vec4<f32>,\r\n    @location(0) color: vec4<f32>,\r\n    @location(1) @interpolate(flat) material_index: i32,\r\n    @location(2) tex_coords_base_color: vec3<f32>,\r\n};\r\n\r\n\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> constant_data: ConstantData;\r\n@group(0) @binding(1)\r\nvar<storage, read> dynamic_data: DynamicData;\r\n@group(0) @binding(2)\r\nvar<storage, read> ui_data: UIData;\r\n\r\n\r\n@group(1) @binding(0)\r\nvar default_sampler: sampler;\r\n@group(1) @binding(1)\r\nvar depth_sampler: sampler;\r\n@group(1) @binding(2)\r\nvar texture_array: binding_array<texture_2d<f32>, 16>; //MAX_TEXTURE_ATLAS_COUNT\r\n\r\n\r\nfn get_textures_coord_set(v: VertexInput, material_index: i32, texture_type: u32) -> vec2<f32> {\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    return v.tex_coords_0;\r\n}\r\n\r\n\r\nfn compute_textures_coord(v: VertexInput, material_index: i32, texture_type: u32) -> vec3<f32> {\r\n    let tex_coords = get_textures_coord_set(v, material_index, texture_type);\r\n    var t = vec3<f32>(0.0, 0.0, 0.0);\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    if (texture_data_index >= 0) {\r\n        t.x = (dynamic_data.textures_data[texture_data_index].area.x + 0.5 + tex_coords.x * dynamic_data.textures_data[texture_data_index].area.z) / dynamic_data.textures_data[texture_data_index].total_width;\r\n        t.y = (dynamic_data.textures_data[texture_data_index].area.y + 0.5 + tex_coords.y * dynamic_data.textures_data[texture_data_index].area.w) / dynamic_data.textures_data[texture_data_index].total_height;\r\n        t.z = f32(dynamic_data.textures_data[texture_data_index].layer_index);\r\n    }\r\n    return t;\r\n}\r\n\r\nfn linear_from_srgb(srgb: vec3<f32>) -> vec3<f32> {\r\n    let cutoff = srgb < vec3<f32>(10.31475);\r\n    let lower = srgb / vec3<f32>(3294.6);\r\n    let higher = pow((srgb + vec3<f32>(14.025)) / vec3<f32>(269.025), vec3<f32>(2.4));\r\n    return select(higher, lower, cutoff);\r\n}\r\n\r\nfn rgba_from_integer(color: u32) -> vec4<f32> {\r\n    return vec4<f32>(\r\n        f32(color & 255u),\r\n        f32((color >> 8u) & 255u),\r\n        f32((color >> 16u) & 255u),\r\n        f32((color >> 24u) & 255u),\r\n    );\r\n}\r\n\r\n@vertex\r\nfn vs_main(\r\n    v: VertexInput,\r\n    instance: InstanceInput,\r\n) -> VertexOutput {\r\n    var vertex_out: VertexOutput;\r\n    let ui_scale = ui_data.scale;\r\n    vertex_out.clip_position = vec4<f32>(2. * v.position.x * ui_scale / constant_data.screen_width - 1., 1. - 2. * v.position.y * ui_scale / constant_data.screen_height, v.position.z, 1.);\r\n    let support_srbg = constant_data.flags & CONSTANT_DATA_FLAGS_SUPPORT_SRGB;\r\n    let color = rgba_from_integer(v.color);\r\n    if (support_srbg == 0u) {\r\n        vertex_out.color = vec4<f32>(color.rgba / 255.);\r\n    } else {\r\n        vertex_out.color = vec4<f32>(linear_from_srgb(color.rgb), color.a / 255.);\r\n    }\r\n    vertex_out.material_index = instance.material_index;\r\n\r\n    if (instance.material_index >= 0) {\r\n        vertex_out.tex_coords_base_color = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_BASE_COLOR);\r\n    }\r\n\r\n    return vertex_out;\r\n}\r\n\r\nfn get_atlas_index(material_index: u32, texture_type: u32) -> u32 {\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    if (texture_data_index < 0) {\r\n        return 0u;\r\n    }\r\n    return dynamic_data.textures_data[texture_data_index].texture_index;\r\n}\r\n\r\nfn get_texture_color(material_index: u32, texture_type: u32, tex_coords: vec3<f32>) -> vec4<f32> {\r\n    let atlas_index = get_atlas_index(material_index, texture_type);\r\n    return textureSampleLevel(texture_array[atlas_index], default_sampler, tex_coords.xy, tex_coords.z);\r\n}\r\n\r\n@fragment\r\nfn fs_main(v: VertexOutput) -> @location(0) vec4<f32> {\r\n    var color: vec4<f32> = v.color;\r\n    if (v.material_index >= 0) {\r\n        color = color * get_texture_color(u32(v.material_index), TEXTURE_TYPE_BASE_COLOR, v.tex_coords_base_color);\r\n    }\r\n    return color;\r\n}"}