{"spirv_code":[],"wgsl_code":"let MAX_TEXTURE_ATLAS_COUNT: u32 = 16u;\r\nlet MAX_NUM_LIGHTS: u32 = 64u;\r\nlet MAX_NUM_TEXTURES: u32 = 512u;\r\nlet MAX_NUM_MATERIALS: u32 = 512u;\r\n\r\nlet TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\r\nlet TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\r\nlet TEXTURE_TYPE_NORMAL: u32 = 2u;\r\nlet TEXTURE_TYPE_EMISSIVE: u32 = 3u;\r\nlet TEXTURE_TYPE_OCCLUSION: u32 = 4u;\r\nlet TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\r\nlet TEXTURE_TYPE_DIFFUSE: u32 = 6u;\r\nlet TEXTURE_TYPE_EMPTY_FOR_PADDING: u32 = 7u;\r\nlet TEXTURE_TYPE_COUNT: u32 = 8u;\r\n\r\nlet CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\r\nlet CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\r\n\r\nstruct ConstantData {\r\n    view: mat4x4<f32>,\r\n    proj: mat4x4<f32>,\r\n    screen_width: f32,\r\n    screen_height: f32,\r\n    flags: u32,\r\n};\r\n\r\nstruct LightData {\r\n    position: vec3<f32>,\r\n    light_type: u32,\r\n    color: vec4<f32>,\r\n    intensity: f32,\r\n    range: f32,\r\n    inner_cone_angle: f32,\r\n    outer_cone_angle: f32,\r\n};\r\n\r\nstruct TextureData {\r\n    texture_index: u32,\r\n    layer_index: u32,\r\n    total_width: f32,\r\n    total_height: f32,\r\n    area: vec4<f32>,\r\n};\r\n\r\nstruct ShaderMaterialData {\r\n    textures_indices: array<i32, 8>,//TEXTURE_TYPE_COUNT>,\r\n    textures_coord_set: array<u32, 8>,//TEXTURE_TYPE_COUNT>,\r\n    roughness_factor: f32,\r\n    metallic_factor: f32,\r\n    alpha_cutoff: f32,\r\n    alpha_mode: u32,\r\n    base_color: vec4<f32>,\r\n    emissive_color: vec4<f32>,\r\n    diffuse_color: vec4<f32>,\r\n    specular_color: vec4<f32>,\r\n};\r\n\r\nstruct DynamicData {\r\n    textures_data: array<TextureData, 512>,//MAX_NUM_TEXTURES>,\r\n    materials_data: array<ShaderMaterialData, 512>,//MAX_NUM_MATERIALS>,\r\n    lights_data: array<LightData, 64>,//MAX_NUM_LIGHTS>,\r\n};\r\n\r\n\r\nstruct VertexInput {\r\n    //@builtin(vertex_index) index: u32,\r\n    @location(0) position: vec3<f32>,\r\n    @location(1) normal: vec3<f32>,\r\n    @location(2) color: vec4<f32>,\r\n    @location(3) tex_coords_0: vec2<f32>,\r\n    @location(4) tex_coords_1: vec2<f32>,\r\n    @location(5) tex_coords_2: vec2<f32>,\r\n    @location(6) tex_coords_3: vec2<f32>,\r\n};\r\n\r\nstruct InstanceInput {\r\n    //@builtin(instance_index) index: u32,\r\n    @location(7) draw_area: vec4<f32>,\r\n    @location(8) model_matrix_0: vec4<f32>,\r\n    @location(9) model_matrix_1: vec4<f32>,\r\n    @location(10) model_matrix_2: vec4<f32>,\r\n    @location(11) model_matrix_3: vec4<f32>,\r\n    @location(12) normal_matrix_0: vec3<f32>,\r\n    @location(13) normal_matrix_1: vec3<f32>,\r\n    @location(14) normal_matrix_2: vec3<f32>,\r\n    @location(15) material_index: i32,\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) clip_position: vec4<f32>,\r\n    @location(0) color: vec4<f32>,\r\n    @location(1) normal: vec3<f32>,\r\n    @location(2) @interpolate(flat) material_index: i32,\r\n    @location(3) tex_coords_base_color: vec3<f32>,\r\n    @location(4) tex_coords_metallic_roughness: vec3<f32>,\r\n    @location(5) tex_coords_normal: vec3<f32>,\r\n    @location(6) tex_coords_emissive: vec3<f32>,\r\n    @location(7) tex_coords_occlusion: vec3<f32>,\r\n    @location(8) tex_coords_specular_glossiness: vec3<f32>,\r\n    @location(9) tex_coords_diffuse: vec3<f32>,\r\n};\r\n\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> constant_data: ConstantData;\r\n@group(0) @binding(1)\r\nvar<storage, read> dynamic_data: DynamicData;\r\n\r\n@group(1) @binding(0)\r\nvar default_sampler: sampler;\r\n@group(1) @binding(1)\r\nvar texture_1: texture_2d<f32>;\r\n@group(1) @binding(2)\r\nvar texture_2: texture_2d<f32>;\r\n@group(1) @binding(3)\r\nvar texture_3: texture_2d<f32>;\r\n@group(1) @binding(4)\r\nvar texture_4: texture_2d<f32>;\r\n@group(1) @binding(5)\r\nvar texture_5: texture_2d<f32>;\r\n@group(1) @binding(6)\r\nvar texture_6: texture_2d<f32>;\r\n@group(1) @binding(7)\r\nvar texture_7: texture_2d<f32>;\r\n@group(1) @binding(8)\r\nvar texture_8: texture_2d<f32>;\r\n@group(1) @binding(9)\r\nvar texture_9: texture_2d<f32>;\r\n@group(1) @binding(10)\r\nvar texture_10: texture_2d<f32>;\r\n@group(1) @binding(11)\r\nvar texture_11: texture_2d<f32>;\r\n@group(1) @binding(12)\r\nvar texture_12: texture_2d<f32>;\r\n@group(1) @binding(13)\r\nvar texture_13: texture_2d<f32>;\r\n@group(1) @binding(14)\r\nvar texture_14: texture_2d<f32>;\r\n@group(1) @binding(15)\r\nvar texture_15: texture_2d<f32>;\r\n@group(1) @binding(16)\r\nvar texture_16: texture_2d<f32>;\r\n\r\nfn get_textures_coord_set(v: VertexInput, material_index: i32, texture_type: u32) -> vec2<f32> {\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    if (texture_data_index >= 0) {\r\n        let textures_coord_set_index = dynamic_data.materials_data[material_index].textures_coord_set[texture_type];\r\n        if (textures_coord_set_index == 1u) {\r\n            return v.tex_coords_1;\r\n        } else if (textures_coord_set_index == 2u) {\r\n            return v.tex_coords_2;\r\n        } else if (textures_coord_set_index == 3u) {\r\n            return v.tex_coords_3;\r\n        }\r\n    }\r\n    return v.tex_coords_0;\r\n}\r\n\r\n\r\nfn compute_textures_coord(v: VertexInput, material_index: i32, texture_type: u32) -> vec3<f32> {\r\n    let tex_coords = get_textures_coord_set(v, material_index, texture_type);\r\n    var t = vec3<f32>(0.0, 0.0, 0.0);\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    if (texture_data_index >= 0) {\r\n        t.x = (dynamic_data.textures_data[texture_data_index].area.x + 0.5 + tex_coords.x * dynamic_data.textures_data[texture_data_index].area.z) / dynamic_data.textures_data[texture_data_index].total_width;\r\n        t.y = (dynamic_data.textures_data[texture_data_index].area.y + 0.5 + tex_coords.y * dynamic_data.textures_data[texture_data_index].area.w) / dynamic_data.textures_data[texture_data_index].total_height;\r\n        t.z = f32(dynamic_data.textures_data[texture_data_index].layer_index);\r\n    }\r\n    return t;\r\n}\r\n\r\n@vertex\r\nfn vs_main(\r\n    v: VertexInput,\r\n    instance: InstanceInput,\r\n) -> VertexOutput {\r\n    let instance_matrix = mat4x4<f32>(\r\n        instance.model_matrix_0,\r\n        instance.model_matrix_1,\r\n        instance.model_matrix_2,\r\n        instance.model_matrix_3,\r\n    );\r\n    let normal_matrix = mat3x3<f32>(\r\n        instance.normal_matrix_0,\r\n        instance.normal_matrix_1,\r\n        instance.normal_matrix_2,\r\n    );\r\n\r\n    var vertex_out: VertexOutput;\r\n    vertex_out.clip_position = constant_data.proj * constant_data.view * instance_matrix * vec4<f32>(v.position, 1.0);\r\n    vertex_out.normal = normalize(normal_matrix * v.normal);\r\n    vertex_out.color = v.color;\r\n    vertex_out.material_index = instance.material_index;\r\n\r\n    if (instance.material_index >= 0) {\r\n        vertex_out.tex_coords_base_color = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_BASE_COLOR);\r\n        vertex_out.tex_coords_metallic_roughness = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_METALLIC_ROUGHNESS);\r\n        vertex_out.tex_coords_normal = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_NORMAL);\r\n        vertex_out.tex_coords_emissive = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_EMISSIVE);\r\n        vertex_out.tex_coords_occlusion = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_OCCLUSION);\r\n        vertex_out.tex_coords_specular_glossiness = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_SPECULAR_GLOSSINESS);\r\n        vertex_out.tex_coords_diffuse = compute_textures_coord(v, instance.material_index, TEXTURE_TYPE_DIFFUSE);\r\n    }\r\n\r\n    return vertex_out;\r\n}\r\n\r\nfn get_atlas_index(material_index: u32, texture_type: u32) -> u32 {\r\n    let texture_data_index = dynamic_data.materials_data[material_index].textures_indices[texture_type];\r\n    if (texture_data_index < 0) {\r\n        return 0u;\r\n    }\r\n    return dynamic_data.textures_data[texture_data_index].texture_index;\r\n}\r\n\r\nfn get_texture_color(material_index: u32, texture_type: u32, tex_coords: vec3<f32>) -> vec4<f32> {\r\n    let atlas_index = get_atlas_index(material_index, texture_type);\r\n    if (atlas_index == 1u) {\r\n        return textureSampleLevel(texture_2, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 2u) {\r\n        return textureSampleLevel(texture_3, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 3u) {\r\n        return textureSampleLevel(texture_4, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 4u) {\r\n        return textureSampleLevel(texture_5, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 5u) {\r\n        return textureSampleLevel(texture_6, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 6u) {\r\n        return textureSampleLevel(texture_7, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 7u) {\r\n        return textureSampleLevel(texture_8, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 8u) {\r\n        return textureSampleLevel(texture_9, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 9u) {\r\n        return textureSampleLevel(texture_10, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 10u) {\r\n        return textureSampleLevel(texture_11, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 11u) {\r\n        return textureSampleLevel(texture_12, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 12u) {\r\n        return textureSampleLevel(texture_13, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 13u) {\r\n        return textureSampleLevel(texture_14, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 14u) {\r\n        return textureSampleLevel(texture_15, default_sampler, tex_coords.xy, tex_coords.z);\r\n    } else if (atlas_index == 15u) {\r\n        return textureSampleLevel(texture_16, default_sampler, tex_coords.xy, tex_coords.z);\r\n    }\r\n    return textureSampleLevel(texture_1, default_sampler, tex_coords.xy, tex_coords.z);\r\n}\r\n\r\n\r\n@fragment\r\nfn fs_main(v: VertexOutput) -> @location(0) vec4<f32> {\r\n    var color: vec4<f32> = v.color;\r\n    if (v.material_index >= 0) {\r\n        color = color * get_texture_color(u32(v.material_index), TEXTURE_TYPE_BASE_COLOR, v.tex_coords_base_color);\r\n    }\r\n\r\n    var color_from_light = color.rgb;\r\n    var i = 0u;\r\n    loop {\r\n        if (dynamic_data.lights_data[i].light_type == 0u) {\r\n            break;\r\n        }\r\n        let light_color = dynamic_data.lights_data[i].color.rgb;\r\n        let ambient_strength = dynamic_data.lights_data[i].intensity / 10000.;\r\n        let ambient_color = light_color * ambient_strength;\r\n\r\n        let light_dir = normalize(dynamic_data.lights_data[i].position - v.clip_position.xyz);\r\n\r\n        let diffuse_strength = max(dot(v.normal, light_dir), 0.0);\r\n        let diffuse_color = light_color * diffuse_strength;\r\n        let view_pos = vec3<f32>(constant_data.view[3][0], constant_data.view[3][1], constant_data.view[3][2]);\r\n        let view_dir = normalize(view_pos - v.clip_position.xyz);\r\n    \r\n\t    //Blinn-Phong\r\n        let half_dir = normalize(view_dir + light_dir);\r\n        let specular_strength = pow(max(dot(v.normal, half_dir), 0.0), 32.);\r\n\r\n        let specular_color = specular_strength * light_color;\r\n\r\n        color_from_light = color_from_light * (ambient_color + diffuse_color + specular_color);\r\n        i = i + 1u;\r\n    }\r\n\r\n    return vec4<f32>(color_from_light.rgb, color.a);\r\n}"}