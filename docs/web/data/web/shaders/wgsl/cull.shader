{"spirv_code":[],"wgsl_code":"\nstruct CullingPassData {\n    cam_pos: vec3<f32>,\n    flags: u32,\n    planes: array<vec4<f32>, 6>,\n};\n\nstruct DrawCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_index: u32,\n    vertex_offset: i32,\n    base_instance: u32,\n};\n\nstruct MeshData {\n    position: vec3<f32>,\n    scale: f32,\n    orientation: vec4<f32>,\n};\n\nstruct MeshletData {\n    center: vec3<f32>,\n    radius: f32,\n    cone_axis: vec3<f32>,\n    cone_cutoff: f32,\n    vertices_count: u32,\n    vertices_offset: u32,\n    indices_count: u32,\n    indices_offset: u32,\n};\n\nstruct Meshlets {\n    meshlets: array<MeshletData>,\n};\nstruct Meshes {\n    meshes: array<MeshData>,\n};\nstruct Commands {\n    commands: array<DrawCommand>,\n};\n\n@group(0) @binding(0)\nvar<uniform> cull_data: CullingPassData;\n@group(0) @binding(1)\nvar<storage, read> meshlets: Meshlets;\n@group(0) @binding(2)\nvar<storage, read> meshes: Meshes;\n@group(0) @binding(3)\nvar<storage, read_write> commands: Commands;\n\n\nfn rotate_quat(pos: vec3<f32>, orientation: vec4<f32>) -> vec3<f32> {\n    return pos + 2.0 * cross(orientation.xyz, cross(orientation.xyz, pos) + orientation.w * pos);\n}\n\nfn is_inside_frustum(cam_pos: vec3<f32>, pos: vec3<f32>, radius: f32) -> bool {\n    var is_inside = true;\n    for (var i = 0; i < 6; i++) {\n        let d = dot(cull_data.planes[i].xyz, pos) - cull_data.planes[i].w;\n        let r = d > -radius;\n        is_inside = is_inside && r;\n    }\n    return is_inside;\n}\n\nfn is_cone_culled(meshlet: MeshletData, mesh: MeshData, camera_position: vec3<f32>) -> bool {\n    let center = rotate_quat(meshlet.center, mesh.orientation) * mesh.scale + mesh.position;\n    let radius = meshlet.radius * mesh.scale;\n    let cone_axis = rotate_quat(vec3<f32>(meshlet.cone_axis[0] / 127., meshlet.cone_axis[1] / 127., meshlet.cone_axis[2] / 127.), mesh.orientation);\n//    let cone_axis = meshlet.cone_axis / 127.;\n    let cone_cutoff = meshlet.cone_cutoff / 127.;\n\n    let direction = center - camera_position;\n    return dot(direction, cone_axis) < cone_cutoff * length(direction) + radius;\n//    let direction = normalize((meshlet.center + mesh.position) - camera_position);\n//    return dot(direction, cone_axis) < cone_cutoff;\n}\n\n\n@compute\n@workgroup_size(32, 1, 1)\nfn main(@builtin(local_invocation_id) local_invocation_id: vec3<u32>, @builtin(local_invocation_index) local_invocation_index: u32, @builtin(global_invocation_id) global_invocation_id: vec3<u32>, @builtin(workgroup_id) workgroup_id: vec3<u32>) {\n    let total = arrayLength(&meshlets.meshlets);\n    let meshlet_index = global_invocation_id.x;\n    if (meshlet_index >= total) {\n        return;\n    }\n    let mesh_index = commands.commands[meshlet_index].base_instance;\n\n    let center = rotate_quat(meshlets.meshlets[meshlet_index].center, meshes.meshes[mesh_index].orientation) * meshes.meshes[mesh_index].scale + meshes.meshes[mesh_index].position;\n    let radius = meshlets.meshlets[meshlet_index].radius * meshes.meshes[mesh_index].scale;\n\n    if (!is_inside_frustum(cull_data.cam_pos, center, radius)) {\n        commands.commands[meshlet_index].instance_count = 0u;\n        return;\n    }\n\n    let cam_pos = cull_data.cam_pos;\n    let is_visible = is_cone_culled(meshlets.meshlets[meshlet_index], meshes.meshes[mesh_index], cam_pos);\n    if (!is_visible) {\n        commands.commands[meshlet_index].instance_count = 0u;\n    }\n}\n"}