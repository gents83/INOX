{
  "spirv_code": [],
  "wgsl_code": "struct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n};\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n};\n\n@group(0) @binding(0)\nvar source_texture: texture_2d<f32>;\n\n\nconst FXAA_SPAN_MAX: f32 = 8.;\nconst FXAA_REDUCE_MUL: f32 = 1. / 8.;\nconst FXAA_REDUCE_MIN: f32 = 1. / 128.;\n\nfn fxaa(t: texture_2d<f32>, p: vec2<f32>, dimensions: vec2<f32>) -> vec3<f32> {\n\n    // 1st stage - Find edge\n\tlet rgbNW = textureLoad(t, vec2<u32>(p + vec2<f32>(-1., -1.) / dimensions), 0).rgb;\n\tlet rgbNE = textureLoad(t, vec2<u32>(p + vec2<f32>(1., -1.) / dimensions), 0).rgb;\n\tlet rgbSW = textureLoad(t, vec2<u32>(p + vec2<f32>(-1., 1.) / dimensions), 0).rgb;\n\tlet rgbSE = textureLoad(t, vec2<u32>(p + vec2<f32>(1., 1.) / dimensions), 0).rgb;\n\tlet rgbM = textureLoad(t, vec2<u32>(p), 0).rgb;\n\n\tlet luma = vec3<f32>(0.299, 0.587, 0.114);\n\tlet lumaNW = dot(rgbNW, luma);\n\tlet lumaNE = dot(rgbNE, luma);\n\tlet lumaSW = dot(rgbSW, luma);\n\tlet lumaSE = dot(rgbSE, luma);\n\tlet lumaM = dot(rgbM, luma);\n\n\tvar dir: vec2<f32>;\n\tdir.x = -(lumaNW + lumaNE - (lumaSW + lumaSE));\n\tdir.y = lumaNW + lumaSW - (lumaNE + lumaSE);\n\tlet lumaSum = lumaNW + lumaNE + lumaSW + lumaSE;\n\tlet dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\tlet rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2<f32>(FXAA_SPAN_MAX), max(vec2<f32>(-FXAA_SPAN_MAX), dir * rcpDirMin)) / dimensions;\n\tlet rgbA = 0.5 * (textureLoad(t, vec2<u32>(p + dir * (1. / 3. - 0.5)), 0).rgb + textureLoad(t, vec2<u32>(p + dir * (2. / 3. - 0.5)), 0).rgb);\n\n    // 2nd stage - Blur\n\tlet rgbB = rgbA * 0.5 + 0.25 * (textureLoad(t, vec2<u32>(p + dir * (0. / 3. - 0.5)), 0).rgb + textureLoad(t, vec2<u32>(p + dir * (3. / 3. - 0.5)), 0).rgb);\n\tlet lumaB = dot(rgbB, luma);\n\tlet lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tlet lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n\treturn select(rgbB, rgbA, lumaB < lumaMin || lumaB > lumaMax);\n} \n\n@vertex\nfn vs_main(@builtin(vertex_index) in_vertex_index: u32) -> VertexOutput {\n    //only one triangle, exceeding the viewport size\n    let uv = vec2<f32>(f32((in_vertex_index << 1u) & 2u), f32(in_vertex_index & 2u));\n    let pos = vec4<f32>(uv * vec2<f32>(2., -2.) + vec2<f32>(-1., 1.), 0., 1.);\n\n    var vertex_out: VertexOutput;\n    vertex_out.clip_position = pos;\n    vertex_out.uv = uv;\n    return vertex_out;\n}\n\n@fragment\nfn fs_main(v_in: VertexOutput) -> @location(0) vec4<f32> {\n    let d = vec2<f32>(textureDimensions(source_texture));\n    let pixel_coords = vec2<f32>(f32(v_in.uv.x * d.x + 0.5), f32(v_in.uv.y * d.y + 0.5));\n\n    var out_color = vec4<f32>(0.); \n\n    //out_color = textureLoad(source_texture, vec2<u32>(pixel_coords), 0); \n    out_color = vec4<f32>(fxaa(source_texture, pixel_coords, d), 1.);\n\n    return out_color;\n}\n"
}