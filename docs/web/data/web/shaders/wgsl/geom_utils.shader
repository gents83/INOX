{"spirv_code":[],"wgsl_code":"\nstruct Derivatives {\n    dx: vec3<f32>,\n    dy: vec3<f32>,\n}\n\nfn compute_barycentrics(a: vec2<f32>, b: vec2<f32>, c: vec2<f32>, p: vec2<f32>) -> vec3<f32> {\n    let v0 = b - a;\n    let v1 = c - a;\n    let v2 = p - a;\n    \n    let d00 = dot(v0, v0);    \n    let d01 = dot(v0, v1);    \n    let d11 = dot(v1, v1);\n    let d20 = dot(v2, v0);\n    let d21 = dot(v2, v1);\n    \n    let inv_denom = 1. / (d00 * d11 - d01 * d01);    \n    let v = (d11 * d20 - d01 * d21) * inv_denom;    \n    let w = (d00 * d21 - d01 * d20) * inv_denom;    \n    let u = 1. - v - w;\n\n    return vec3 (u,v,w);\n}\n// Engel's barycentric coord partial derivs function. Follows equation from [Schied][Dachsbacher]\n// Computes the partial derivatives of point's barycentric coordinates from the projected screen space vertices\nfn compute_partial_derivatives(v0: vec2<f32>, v1: vec2<f32>, v2: vec2<f32>) -> Derivatives\n{\n    let d = 1. / determinant(mat2x2<f32>(v2-v1, v0-v1));\n    \n    var deriv: Derivatives;\n    deriv.dx = vec3<f32>(v1.y - v2.y, v2.y - v0.y, v0.y - v1.y) * d;\n    deriv.dy = vec3<f32>(v2.x - v1.x, v0.x - v2.x, v1.x - v0.x) * d;\n    return deriv;\n}\n\n// Interpolate 2D attributes using the partial derivatives and generates dx and dy for texture sampling.\nfn interpolate_2d_attribute(a0: vec2<f32>, a1: vec2<f32>, a2: vec2<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec2<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attribute_x = vec2<f32>(dot(deriv.dx, attr0), dot(deriv.dx, attr1));\n\tlet attribute_y = vec2<f32>(dot(deriv.dy, attr0), dot(deriv.dy, attr1));\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\n\n// Interpolate vertex attributes at point 'd' using the partial derivatives\nfn interpolate_3d_attribute(a0: vec3<f32>, a1: vec3<f32>, a2: vec3<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec3<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attr2 = vec3<f32>(a0.z, a1.z, a2.z);\n    let attributes = mat3x3<f32>(a0, a1, a2);\n\tlet attribute_x = attributes * deriv.dx;\n\tlet attribute_y = attributes * deriv.dy;\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\n"}