{
  "spirv_code": [],
  "wgsl_code": "const MAX_TEXTURE_ATLAS_COUNT: u32 = 8u;\nconst MAX_TEXTURE_COORDS_SET: u32 = 4u;\n\nconst TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\nconst TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\nconst TEXTURE_TYPE_NORMAL: u32 = 2u;\nconst TEXTURE_TYPE_EMISSIVE: u32 = 3u;\nconst TEXTURE_TYPE_OCCLUSION: u32 = 4u;\nconst TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\nconst TEXTURE_TYPE_DIFFUSE: u32 = 6u;\nconst TEXTURE_TYPE_SPECULAR: u32 = 7u;\nconst TEXTURE_TYPE_SPECULAR_COLOR: u32 = 8u;\nconst TEXTURE_TYPE_TRANSMISSION: u32 = 9u;\nconst TEXTURE_TYPE_THICKNESS: u32 = 10u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING_3: u32 = 11u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING_4: u32 = 12u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING_5: u32 = 13u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING_6: u32 = 14u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING_7: u32 = 15u;\nconst TEXTURE_TYPE_COUNT: u32 = 16u;\n\nconst MATERIAL_ALPHA_BLEND_OPAQUE = 0u;\nconst MATERIAL_ALPHA_BLEND_MASK = 1u;\nconst MATERIAL_ALPHA_BLEND_BLEND = 2u;\n\nconst MESH_FLAGS_NONE: u32 = 0u;\nconst MESH_FLAGS_VISIBLE: u32 = 1u;\nconst MESH_FLAGS_OPAQUE: u32 = 1u << 1u;\nconst MESH_FLAGS_TRANSPARENT: u32 = 1u << 2u;\nconst MESH_FLAGS_WIREFRAME: u32 = 1u << 3u;\nconst MESH_FLAGS_DEBUG: u32 = 1u << 4u;\nconst MESH_FLAGS_UI: u32 = 1u << 5u;\n\nconst CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\nconst CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS: u32 = 1u << 1u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_BOUNDING_BOX: u32 = 1u << 2u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_CONE_AXIS: u32 = 1u << 3u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_RADIANCE_BUFFER: u32 = 1u << 4u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_DEPTH_BUFFER: u32 = 1u << 5u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_PATHTRACE: u32 = 1u << 6u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_NORMALS: u32 = 1u << 7u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_TANGENT: u32 = 1u << 8u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_BITANGENT: u32 = 1u << 9u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_BASE_COLOR: u32 = 1u << 10u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_METALLIC: u32 = 1u << 11u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_ROUGHNESS: u32 = 1u << 12u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_UV_0: u32 = 1u << 13u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_UV_1: u32 = 1u << 14u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_UV_2: u32 = 1u << 15u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_UV_3: u32 = 1u << 16u;\nconst CONSTANT_DATA_FLAGS_USE_IBL: u32 = 1u << 17u;\n\n\nconst MATH_PI: f32 = 3.14159265359;\nconst MATH_EPSILON = 0.0000001;\nconst MAX_FLOAT: f32 = 3.402823466e+38;\nconst MAX_TRACING_DISTANCE: f32 = 500.;\nconst HIT_EPSILON: f32 = 0.0001;\nconst INVALID_NODE: i32 = -1;\n\nconst VERTEX_ATTRIBUTE_HAS_POSITION: u32 = 0u;\nconst VERTEX_ATTRIBUTE_HAS_COLOR: u32 = 1u;\nconst VERTEX_ATTRIBUTE_HAS_NORMAL: u32 = 1u << 1u;\nconst VERTEX_ATTRIBUTE_HAS_TANGENT: u32 = 1u << 2u;\nconst VERTEX_ATTRIBUTE_HAS_UV1: u32 = 1u << 3u;\nconst VERTEX_ATTRIBUTE_HAS_UV2: u32 = 1u << 4u;\nconst VERTEX_ATTRIBUTE_HAS_UV3: u32 = 1u << 5u;\nconst VERTEX_ATTRIBUTE_HAS_UV4: u32 = 1u << 6u;\n\nconst MATERIAL_FLAGS_NONE: u32 = 0u;\nconst MATERIAL_FLAGS_UNLIT: u32 = 1u;\nconst MATERIAL_FLAGS_IRIDESCENCE: u32 = 1u << 1u;\nconst MATERIAL_FLAGS_ANISOTROPY: u32 = 1u << 2u;\nconst MATERIAL_FLAGS_CLEARCOAT: u32 = 1u << 3u;\nconst MATERIAL_FLAGS_SHEEN: u32 = 1u << 4u;\nconst MATERIAL_FLAGS_TRANSMISSION: u32 = 1u << 5u;\nconst MATERIAL_FLAGS_VOLUME: u32 = 1u << 6u;\nconst MATERIAL_FLAGS_EMISSIVE_STRENGTH: u32 = 1u << 7u;\nconst MATERIAL_FLAGS_METALLICROUGHNESS: u32 = 1u << 8u;\nconst MATERIAL_FLAGS_SPECULAR: u32 = 1u << 9u;\nconst MATERIAL_FLAGS_SPECULARGLOSSINESS: u32 = 1u << 10u;\nconst MATERIAL_FLAGS_IOR: u32 = 1u << 11u;\nconst MATERIAL_FLAGS_ALPHAMODE_OPAQUE: u32 = 1u << 12u;\nconst MATERIAL_FLAGS_ALPHAMODE_MASK: u32 = 1u << 13u;\nconst MATERIAL_FLAGS_ALPHAMODE_BLEND: u32 = 1u << 14u;\n\nconst LIGHT_TYPE_INVALID: u32 = 0u;\nconst LIGHT_TYPE_DIRECTIONAL: u32 = 1u;\nconst LIGHT_TYPE_POINT: u32 = 1u << 1u;\nconst LIGHT_TYPE_SPOT: u32 = 1u << 2u;\n\nstruct ConstantData {\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    inverse_view_proj: mat4x4<f32>,\n    screen_width: f32,\n    screen_height: f32,\n    frame_index: u32,\n    flags: u32,\n    debug_uv_coords: vec2<f32>,\n    tlas_starting_index: u32,\n    indirect_light_num_bounces: u32\n};\n\nstruct RuntimeVertexData {\n    @location(0) world_pos: vec3<f32>,\n    @location(1) @interpolate(flat) mesh_index: u32,\n};\n\nstruct DrawCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_vertex: u32,\n    base_instance: u32,\n};\n\nstruct DrawIndexedCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_index: u32,\n    vertex_offset: i32,\n    base_instance: u32,\n};\n\nstruct DispatchCommandSize {\n    x: atomic<u32>,\n    y: atomic<u32>,\n    z: atomic<u32>,\n};\n\nstruct Mesh {\n    vertices_position_offset: u32,\n    vertices_attribute_offset: u32,\n    flags_and_vertices_attribute_layout: u32,\n    material_index: i32,\n    orientation: vec4<f32>,\n    position: vec3<f32>,\n    meshlets_offset: u32,\n    scale: vec3<f32>,\n    blas_index: u32,\n};\n\nstruct Meshlet {\n    @location(5) mesh_index: u32,\n    @location(6) indices_offset: u32,\n    @location(7) indices_count: u32,\n    @location(8) triangles_bhv_index: u32,\n    @location(9) center: vec3<f32>,\n    @location(10) cone_axis_cutoff: u32,\n};\n\nstruct BHVNode {\n    min: vec3<f32>,\n    miss: i32,\n    max: vec3<f32>,\n    reference: i32, //-1 or mesh_index or meshlet_index or triangle_index\n};\n\n\nstruct LightData {\n    position: vec3<f32>,\n    light_type: u32,\n    direction: vec3<f32>,\n    intensity: f32,\n    color: vec3<f32>,\n    range: f32,\n    inner_cone_angle: f32,\n    outer_cone_angle: f32,\n    _padding1: f32,\n    _padding2: f32,\n};\n\nstruct TextureData {\n    texture_index: u32,\n    layer_index: u32,\n    total_width: u32,\n    total_height: u32,\n    area: vec4<u32>,\n};\n\nstruct Material {\n    roughness_factor: f32,\n    metallic_factor: f32,\n    ior: f32,\n    transmission_factor: f32,\n    base_color: vec4<f32>,\n    emissive_color: vec3<f32>,\n    emissive_strength: f32,\n    diffuse_color: vec4<f32>,\n    specular_color: vec4<f32>,\n    specular_factors: vec4<f32>,\n    attenuation_color_and_distance: vec4<f32>,\n    thickness_factor: f32,\n    alpha_cutoff: f32,\n    occlusion_strength: f32,\n    flags: u32,\n    textures_index_and_coord_set: array<u32, TEXTURE_TYPE_COUNT>,\n};\n\n\nstruct Lights {\n    data: array<LightData>,\n};\n\nstruct Textures {\n    data: array<TextureData>,\n};\n\nstruct Materials {\n    data: array<Material>,\n};\n\nstruct DrawCommands {\n    data: array<DrawCommand>,\n};\n\nstruct DrawIndexedCommands {\n    data: array<DrawIndexedCommand>,\n};\n\nstruct Meshes {\n    data: array<Mesh>,\n};\n\nstruct Meshlets {\n    data: array<Meshlet>,\n};\n\nstruct Indices {\n    data: array<u32>,\n};\n\nstruct RuntimeVertices {\n    data: array<RuntimeVertexData>,\n};\n\nstruct VerticesPositions {\n    data: array<u32>,\n};\n\nstruct VerticesAttributes {\n    data: array<u32>,\n};\n\nstruct BHV {\n    data: array<BHVNode>,\n};\n\n\nstruct Ray {\n    origin: vec3<f32>,\n    t_min: f32,\n    direction: vec3<f32>,\n    t_max: f32,\n};\n\nstruct RadianceData {\n    origin: vec3<f32>,\n    seed_x: u32,\n    direction: vec3<f32>,\n    seed_y: u32,\n    radiance: vec3<f32>,\n    pixel: u32,\n    throughput_weight: vec3<f32>,\n    bounce: u32,\n};\n\nstruct RadianceDataBuffer {\n    data: array<RadianceData>,\n};\n\nstruct PixelData {\n    world_pos: vec3<f32>,\n    material_id: u32,\n    color: vec4<f32>,\n    normal: vec3<f32>,\n    mesh_scale: f32, \n    tangent: vec4<f32>,\n    uv_set: array<vec2<f32>, 4>,\n};\n\nstruct TBN {\n    normal: vec3<f32>,\n    tangent: vec3<f32>,\n    binormal: vec3<f32>,\n}\n\nstruct MaterialInfo {\n    base_color: vec4<f32>,\n\n    f0: vec3<f32>,\n    ior: f32,\n\n    c_diff: vec3<f32>,\n    perceptual_roughness: f32,\n\n    metallic: f32,\n    specular_weight_and_anisotropy_strength: u32,\n    transmission_factor: f32,\n    thickness_factor: f32,\n\n    attenuation_color_and_distance: vec4<f32>,\n    sheen_color_and_roughness_factor: vec4<f32>,\n\n    clear_coat_f0: vec3<f32>,\n    clear_coat_factor: f32,\n\n    clear_coat_f90: vec3<f32>,\n    clear_coat_roughness_factor: f32,\n\n    clear_coat_normal: vec3<f32>,\n    iridescence_factor: f32,\n\n    anisotropicT: vec3<f32>,\n    iridescence_ior: f32,\n\n    anisotropicB: vec3<f32>,\n    iridescence_thickness: f32,\n\n    alpha_roughness: f32,\n    f90: vec3<f32>,\n    \n    f_color: vec4<f32>,\n    f_emissive: vec3<f32>,\n    f_diffuse: vec3<f32>,\n    f_diffuse_ibl: vec3<f32>,\n    f_specular: vec3<f32>,\n}\nfn quantize_unorm(v: f32, n: u32) -> u32 {\n    let scale = f32((1u << n) - 1u);\n    return u32(0.5 + (v * scale));\n}\nfn quantize_snorm(v: f32, n: u32) -> u32 {\n    let c = (1u << (n - 1u)) - 1u;\n    let scale = f32(c);\n    if v < 0. {\n        return (u32(-v * scale) & c) | (1u << (n - 1u));\n    } else {\n        return u32(v * scale) & c;\n    }\n}\n\nfn decode_unorm(i: u32, n: u32) -> f32 {    \n    let scale = f32((1u << n) - 1u);\n    if (i == 0u) {\n        return 0.;\n    } else if (i == u32(scale)) {\n        return 1.;\n    } else {\n        return (f32(i) - 0.5) / scale;\n    }\n}\n\nfn decode_snorm(i: u32, n: u32) -> f32 {\n    let s = i >> (n - 1u);\n    let c = (1u << (n - 1u)) - 1u;\n    let scale = f32(c);\n    if s > 0u {\n        let r = f32(i & c) / scale;\n        return -r;\n    } else {\n        return f32(i & c) / scale;\n    }\n}\n\nfn pack_3_f32_to_unorm(value: vec3<f32>) -> u32 {\n    let x = quantize_unorm(value.x, 10u) << 20u;\n    let y = quantize_unorm(value.y, 10u) << 10u;\n    let z = quantize_unorm(value.z, 10u);\n    return (x | y | z);\n}\nfn unpack_unorm_to_3_f32(v: u32) -> vec3<f32> {\n    let vx = decode_unorm((v >> 20u) & 0x000003FFu, 10u);\n    let vy = decode_unorm((v >> 10u) & 0x000003FFu, 10u);\n    let vz = decode_unorm(v & 0x000003FFu, 10u);\n    return vec3<f32>(vx, vy, vz);\n}\n\nfn pack_3_f32_to_snorm(value: vec3<f32>) -> u32 {\n    let x = quantize_snorm(value.x, 10u) << 20u;\n    let y = quantize_snorm(value.y, 10u) << 10u;\n    let z = quantize_snorm(value.z, 10u);\n    return (x | y | z);\n}\nfn unpack_snorm_to_3_f32(v: u32) -> vec3<f32> {\n    let vx = decode_snorm((v >> 20u) & 0x000003FFu, 10u);\n    let vy = decode_snorm((v >> 10u) & 0x000003FFu, 10u);\n    let vz = decode_snorm(v & 0x000003FFu, 10u);\n    return vec3<f32>(vx, vy, vz);\n}\n\nfn pack_normal(normal: vec3<f32>) -> vec2<f32> {\n    return vec2<f32>(normal.xy * 0.5 + 0.5);\n}\nfn unpack_normal(uv: vec2<f32>) -> vec3<f32> {\n    return vec3<f32>(uv.xy * 2. - 1., sqrt(1.-dot(uv.xy, uv.xy)));\n}\n\nfn pack_4_f32_to_unorm(value: vec4<f32>) -> u32 {\n    let r = quantize_unorm(value.x, 8u) << 24u;\n    let g = quantize_unorm(value.y, 8u) << 16u;\n    let b = quantize_unorm(value.z, 8u) << 8u;\n    let a = quantize_unorm(value.w, 8u);\n    return (r | g | b | a);\n}\nfn unpack_snorm_to_4_f32(v: u32) -> vec4<f32> {\n    let r = decode_snorm((v >> 24u) & 255u, 8u);\n    let g = decode_snorm((v >> 16u) & 255u, 8u);\n    let b = decode_snorm((v >> 8u) & 255u, 8u);\n    let a = decode_snorm(v & 255u, 8u);\n    return vec4<f32>(r,g,b,a);\n}\nfn unpack_unorm_to_4_f32(v: u32) -> vec4<f32> {\n    let r = decode_unorm((v >> 24u) & 255u, 8u);\n    let g = decode_unorm((v >> 16u) & 255u, 8u);\n    let b = decode_unorm((v >> 8u) & 255u, 8u);\n    let a = decode_unorm(v & 255u, 8u);\n    return vec4<f32>(r,g,b,a);\n}\n\nfn iq_hash(v: vec2<f32>) -> f32 {\n    return fract(sin(dot(v, vec2(11.9898, 78.233))) * 43758.5453);\n}\nfn blue_noise(in: vec2<f32>) -> f32 {\n    var v =  iq_hash( in + vec2<f32>(-1., 0.) )\n             + iq_hash( in + vec2<f32>( 1., 0.) )\n             + iq_hash( in + vec2<f32>( 0., 1.) )\n             + iq_hash( in + vec2<f32>( 0.,-1.) ); \n    v /= 4.;\n    return (iq_hash(in) - v + .5);\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nfn hash( x: u32 ) -> u32 {\n    var v = x;\n    v += ( v << 10u );\n    v ^= ( v >>  6u );\n    v += ( v <<  3u );\n    v ^= ( v >> 11u );\n    v += ( v << 15u );\n    return v;\n}\n\nfn hash1(seed: f32) -> f32 {\n    var p = fract(seed * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfn hash2(seed: ptr<function, f32>) -> vec2<f32> {\n    let a = (*seed) + 0.1;\n    let b = a + 0.1;\n    (*seed) = b;\n    return fract(sin(vec2(a,b))*vec2(43758.5453123,22578.1459123));\n}\n\nfn hash3(seed: ptr<function, f32>) -> vec3<f32> {\n    let a = (*seed) + 0.1;\n    let b = a + 0.1;\n    let c = b + 0.1;\n    (*seed) = c;\n    return fract(sin(vec3(a,b,c))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// This is PCG2d\nfn get_random_numbers(seed: ptr<function, vec2<u32>>) -> vec2<f32> {\n    var v = (*seed) * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u; v.y += v.x * 1664525u;\n    v ^= v >> vec2u(16u);\n    v.x += v.y * 1664525u; v.y += v.x * 1664525u;\n    v ^= v >> vec2u(16u);\n    *seed = v;\n    return vec2<f32>(v) * 2.32830643654e-10;\n}\n\nfn swap_f32(ptr_a: ptr<function, f32>, ptr_b: ptr<function, f32>) \n{\n    let c = *ptr_a;\n    *ptr_a = *ptr_b;\n    *ptr_b = c;\n}\n\nfn mod_f32(v: f32, m: f32) -> f32\n{\n    return v - (m * floor(v/m));\n}\n\nfn clamped_dot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n    return clamp(dot(a,b), 0., 1.);\n}\n\nfn has_vertex_attribute(vertex_attribute_layout: u32, attribute_to_check: u32) -> bool {\n    return bool(vertex_attribute_layout & attribute_to_check);\n}\nfn vertex_attribute_offset(vertex_attribute_layout: u32, attribute_to_check: u32) -> i32 \n{\n    if(has_vertex_attribute(vertex_attribute_layout, attribute_to_check)) {\n        let mask = (vertex_attribute_layout & 0x0000FFFFu) & (~attribute_to_check & (attribute_to_check - 1u));\n        return i32(countOneBits(mask));\n    }\n    return -1;\n}\nfn vertex_layout_stride(vertex_attribute_layout: u32) -> u32 \n{\n    return countOneBits((vertex_attribute_layout & 0x0000FFFFu));\n}\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n};\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n};\n\n\n@group(0) @binding(0)\nvar<uniform> constant_data: ConstantData;\n@group(0) @binding(1)\nvar<storage, read> indices: Indices;\n@group(0) @binding(2)\nvar<storage, read> runtime_vertices: RuntimeVertices;\n@group(0) @binding(3)\nvar<storage, read> vertices_attributes: VerticesAttributes;\n@group(0) @binding(4)\nvar<storage, read> meshes: Meshes;\n@group(0) @binding(5)\nvar<storage, read> meshlets: Meshlets;\n\n@group(1) @binding(0)\nvar<storage, read> materials: Materials;\n@group(1) @binding(1)\nvar<storage, read> textures: Textures;\n@group(1) @binding(2)\nvar<storage, read> lights: Lights;\n@group(1) @binding(3)\nvar finalize_texture: texture_2d<f32>;\n@group(1) @binding(4)\nvar visibility_texture: texture_2d<u32>;\n@group(1) @binding(5)\nvar radiance_texture: texture_2d<f32>;\n@group(1) @binding(6)\nvar depth_texture: texture_depth_2d;\n@group(1) @binding(7)\nvar debug_data_texture: texture_2d<f32>;\n\n@group(2) @binding(0)\nvar default_sampler: sampler;\n\n@group(2) @binding(1)\nvar texture_1: texture_2d_array<f32>;\n@group(2) @binding(2)\nvar texture_2: texture_2d_array<f32>;\n@group(2) @binding(3)\nvar texture_3: texture_2d_array<f32>;\n@group(2) @binding(4)\nvar texture_4: texture_2d_array<f32>;\n@group(2) @binding(5)\nvar texture_5: texture_2d_array<f32>;\n@group(2) @binding(6)\nvar texture_6: texture_2d_array<f32>;\n@group(2) @binding(7)\nvar texture_7: texture_2d_array<f32>;\n\n\nfn sample_texture(tex_coords_and_texture_index: vec3<f32>) -> vec4<f32> {\n    let texture_data_index = i32(tex_coords_and_texture_index.z);\n    var v = vec4<f32>(0.);\n    var tex_coords = vec3<f32>(0.0, 0.0, 0.0);\n    if (texture_data_index < 0) {\n        return v;\n    }\n    let texture = &textures.data[texture_data_index];\n    let atlas_index = (*texture).texture_index;\n    let layer_index = i32((*texture).layer_index);\n\n    tex_coords.x = (f32((*texture).area.x) + mod_f32(tex_coords_and_texture_index.x, 1.) * f32((*texture).area.z)) / f32((*texture).total_width);\n    tex_coords.y = (f32((*texture).area.y) + mod_f32(tex_coords_and_texture_index.y, 1.) * f32((*texture).area.w)) / f32((*texture).total_height);\n    tex_coords.z = f32(layer_index);\n\n    switch (atlas_index) {\n        case 0u: { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 1u: { v = textureSampleLevel(texture_2, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 2u: { v = textureSampleLevel(texture_3, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 3u: { v = textureSampleLevel(texture_4, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 4u: { v = textureSampleLevel(texture_5, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 5u: { v = textureSampleLevel(texture_6, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 6u: { v = textureSampleLevel(texture_7, default_sampler, tex_coords.xy, layer_index, 0.); }\n        default { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n    };\n    return v;\n}\n\nstruct Derivatives {\n    dx: vec3<f32>,\n    dy: vec3<f32>,\n}\n\nfn pixel_to_normalized(image_pixel: vec2<u32>, image_size: vec2<u32>) -> vec2<f32> {\n    return ((vec2<f32>(0.5) + vec2<f32>(image_pixel)) / vec2<f32>(image_size));\n}\n\nfn pixel_to_clip(image_pixel: vec2<u32>, image_size: vec2<u32>) -> vec2<f32> {\n    var clip_coords = 2. * pixel_to_normalized(image_pixel, image_size) - vec2<f32>(1.);\n    clip_coords.y = -clip_coords.y;\n    return clip_coords;\n}\n\nfn pixel_to_world(image_pixel: vec2<u32>, image_size: vec2<u32>, depth: f32) -> vec3<f32> {\n    let clip_coords = pixel_to_clip(image_pixel, image_size);\n    let world_pos = clip_to_world(clip_coords, depth);\n    return world_pos;\n}\n\nfn clip_to_world(clip_coords: vec2<f32>, depth: f32) -> vec3<f32> {    \n    var world_pos = constant_data.inverse_view_proj * vec4<f32>(clip_coords, depth, 1.);\n    world_pos /= world_pos.w;\n    return world_pos.xyz;\n}\n\nfn compute_barycentrics_3d(p1: vec3<f32>, p2: vec3<f32>, p3: vec3<f32>, p: vec3<f32>) -> vec3<f32> {\n    let v1 = p - p1;\n    let v2 = p - p2;\n    let v3 = p - p3;\n    \n    let area = length(cross(v1 - v2, v1 - v3)); \n    return vec3<f32>(length(cross(v2, v3)) / area, length(cross(v3, v1)) / area, length(cross(v1, v2)) / area); \n}\n\nfn compute_barycentrics_2d(a: vec2<f32>, b: vec2<f32>, c: vec2<f32>, p: vec2<f32>) -> vec3<f32> {\n    let v0 = b - a;\n    let v1 = c - a;\n    let v2 = p - a;\n    \n    let d00 = dot(v0, v0);    \n    let d01 = dot(v0, v1);    \n    let d11 = dot(v1, v1);\n    let d20 = dot(v2, v0);\n    let d21 = dot(v2, v1);\n    \n    let inv_denom = 1. / (d00 * d11 - d01 * d01);    \n    let v = (d11 * d20 - d01 * d21) * inv_denom;    \n    let w = (d00 * d21 - d01 * d20) * inv_denom;    \n    let u = 1. - v - w;\n\n    return vec3 (u,v,w);\n}\n\n// Engel's barycentric coord partial derivs function. Follows equation from [Schied][Dachsbacher]\n// Computes the partial derivatives of point's barycentric coordinates from the projected screen space vertices\nfn compute_partial_derivatives(v0: vec2<f32>, v1: vec2<f32>, v2: vec2<f32>) -> Derivatives\n{\n    let d = 1. / determinant(mat2x2<f32>(v2-v1, v0-v1));\n    \n    return Derivatives(vec3<f32>(v1.y - v2.y, v2.y - v0.y, v0.y - v1.y) * d, vec3<f32>(v2.x - v1.x, v0.x - v2.x, v1.x - v0.x) * d);\n}\n\n// Interpolate 2D attributes using the partial derivatives and generates dx and dy for texture sampling.\nfn interpolate_2d_attribute(a0: vec2<f32>, a1: vec2<f32>, a2: vec2<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec2<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attribute_x = vec2<f32>(dot(deriv.dx, attr0), dot(deriv.dx, attr1));\n\tlet attribute_y = vec2<f32>(dot(deriv.dy, attr0), dot(deriv.dy, attr1));\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\n\n// Interpolate vertex attributes at point 'd' using the partial derivatives\nfn interpolate_3d_attribute(a0: vec3<f32>, a1: vec3<f32>, a2: vec3<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec3<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attr2 = vec3<f32>(a0.z, a1.z, a2.z);\n    let attributes = mat3x3<f32>(a0, a1, a2);\n\tlet attribute_x = attributes * deriv.dx;\n\tlet attribute_y = attributes * deriv.dy;\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\n\nfn draw_line(uv: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, width: f32) -> f32 {\n    let d = p2 - p1;\n    let t = clamp(dot(d,uv-p1) / dot(d,d), 0., 1.);\n    let proj = p1 + d * t;\n    return 1. - smoothstep(0., width, length(uv - proj));\n}\n\nfn draw_circle(uv: vec2<f32>, center: vec2<f32>, radius: f32, width: f32) -> f32 {\n    let p = uv - center;\n    let d = sqrt(dot(p,p));\n    return 1. - smoothstep(0., width, abs(radius-d));\n}\n\nfn draw_line_3d(image_pixel: vec2<u32>, image_size: vec2<u32>, start: vec3<f32>, end: vec3<f32>, line_color: vec3<f32>, size: f32) -> vec3<f32>\n{    \n    let origin = pixel_to_world(image_pixel, image_size, -1.);\n    let far = pixel_to_world(image_pixel, image_size, 1.);\n    let direction = normalize(far - origin);\n\n    let line_dir = normalize(end-start);\n    let v1 = start-origin;\n\tlet d0 = dot(direction, line_dir);\n    let d1 = dot(direction, v1);\n    let d2 = dot(line_dir, v1);\n\tvar len = (d0*d1-d2)/(1.-d0*d0);\n    len = clamp(len, 0., length(end-start));\n    let p = start+line_dir*len;\n    let value = length(cross(p-origin, direction));\n    return mix(line_color, vec3<f32>(0.), 1.-size/value);\n}\n\nfn extract_scale(m: mat4x4<f32>) -> vec3<f32> \n{\n    let s = mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);\n    let sx = length(s[0]);\n    let sy = length(s[1]);\n    let det = determinant(s);\n    var sz = length(s[2]);\n    if (det < 0.) \n    {\n        sz = -sz;\n    }\n    return vec3<f32>(sx, sy, sz);\n}\n\nfn matrix_row(m: mat4x4<f32>, row: u32) -> vec4<f32> \n{\n    if (row == 1u) {\n        return vec4<f32>(m[0].y, m[1].y, m[2].y, m[3].y);\n    } else if (row == 2u) {\n        return vec4<f32>(m[0].z, m[1].z, m[2].z, m[3].z);\n    } else if (row == 3u) {\n        return vec4<f32>(m[0].w, m[1].w, m[2].w, m[3].w);\n    } else {        \n        return vec4<f32>(m[0].x, m[1].x, m[2].x, m[3].x);\n    }\n}\n\nfn normalize_plane(plane: vec4<f32>) -> vec4<f32> \n{\n    return (plane / length(plane.xyz));\n}\n\nfn rotate_vector(v: vec3<f32>, orientation: vec4<f32>) -> vec3<f32> \n{\n    return v + 2. * cross(orientation.xyz, cross(orientation.xyz, v) + orientation.w * v);\n}\n\nfn transform_vector(v: vec3<f32>, position: vec3<f32>, orientation: vec4<f32>, scale: vec3<f32>) -> vec3<f32> \n{\n    return rotate_vector(v, orientation) * scale + position;\n}\n\nfn matrix_from_translation(translation: vec3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>(vec4<f32>(1.0, 0.0, 0.0, 0.0),\n                      vec4<f32>(0.0, 1.0, 0.0, 0.0),\n                      vec4<f32>(0.0, 0.0, 1.0, 0.0),\n                      vec4<f32>(translation.x, translation.y, translation.z, 1.0));\n}\n\nfn matrix_from_scale(scale: vec3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>(vec4<f32>(scale.x, 0.0, 0.0, 0.0),\n                      vec4<f32>(0.0, scale.y, 0.0, 0.0),\n                      vec4<f32>(0.0, 0.0, scale.z, 0.0),\n                      vec4<f32>(0.0, 0.0, 0.0, 1.0));\n}\n\nfn matrix_from_orientation(q: vec4<f32>) -> mat4x4<f32> {\n    let xx = q.x * q.x;\n    let yy = q.y * q.y;\n    let zz = q.z * q.z;\n    let xy = q.x * q.y;\n    let xz = q.x * q.z;\n    let yz = q.y * q.z;\n    let wx = q.w * q.x;\n    let wy = q.w * q.y;\n    let wz = q.w * q.z;\n\n    let m00 = 1.0 - 2.0 * (yy + zz);\n    let m01 = 2.0 * (xy - wz);\n    let m02 = 2.0 * (xz + wy);\n\n    let m10 = 2.0 * (xy + wz);\n    let m11 = 1.0 - 2.0 * (xx + zz);\n    let m12 = 2.0 * (yz - wx);\n\n    let m20 = 2.0 * (xz - wy);\n    let m21 = 2.0 * (yz + wx);\n    let m22 = 1.0 - 2.0 * (xx + yy);\n\n    // Utilizza la funzione mat4x4 per creare la matrice 4x4\n    return mat4x4<f32>(\n        vec4<f32>(m00, m01, m02, 0.0),\n        vec4<f32>(m10, m11, m12, 0.0),\n        vec4<f32>(m20, m21, m22, 0.0),\n        vec4<f32>(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nfn transform_matrix(position: vec3<f32>, orientation: vec4<f32>, scale: vec3<f32>) -> mat4x4<f32> {\n    let translation_matrix = matrix_from_translation(position);\n    let rotation_matrix = matrix_from_orientation(orientation);\n    let scale_matrix = matrix_from_scale(scale);    \n    return translation_matrix * rotation_matrix * scale_matrix;\n}\n\nfn matrix_inverse(m: mat4x4<f32>) -> mat4x4<f32> {\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    \n    // Ottimizzazione: Calcola l'inverso del determinante una sola volta\n    let invDet = 1.0 / det;\n\n    return mat4x4<f32>(\n        vec4<f32>((a11 * b11 - a12 * b10 + a13 * b09) * invDet, (a02 * b10 - a01 * b11 - a03 * b09) * invDet, (a31 * b05 - a32 * b04 + a33 * b03) * invDet, (a22 * b04 - a21 * b05 - a23 * b03) * invDet),\n        vec4<f32>((a12 * b08 - a10 * b11 - a13 * b07) * invDet, (a00 * b11 - a02 * b08 + a03 * b07) * invDet, (a32 * b02 - a30 * b05 - a33 * b01) * invDet, (a20 * b05 - a22 * b02 + a23 * b01) * invDet),\n        vec4<f32>((a10 * b10 - a11 * b08 + a13 * b06) * invDet, (a01 * b08 - a00 * b10 - a03 * b06) * invDet, (a30 * b04 - a31 * b02 + a33 * b00) * invDet, (a21 * b02 - a20 * b04 - a23 * b00) * invDet),\n        vec4<f32>((a11 * b07 - a10 * b09 - a12 * b06) * invDet, (a00 * b09 - a01 * b07 + a02 * b06) * invDet, (a31 * b01 - a30 * b03 - a32 * b00) * invDet, (a20 * b03 - a21 * b01 + a22 * b00) * invDet)\n    );\n}\nfn has_texture(material: ptr<function, Material>, texture_type: u32) -> bool {\n    let texture_index = (*material).textures_index_and_coord_set[texture_type] & 0x0FFFFFFFu;\n    if (texture_index > 0) {\n        return true;\n    }\n    return false;\n}\n\nfn material_texture_index(material: ptr<function, Material>, texture_type: u32) -> u32 {\n    let texture_index = (*material).textures_index_and_coord_set[texture_type] & 0x0FFFFFFFu;\n    return max(0u, texture_index - 1u);\n}\n\nfn material_texture_coord_set(material: ptr<function, Material>, texture_type: u32) -> u32 {\n    return ((*material).textures_index_and_coord_set[texture_type] & 0xF0000000u) >> 28;\n}\n\nfn material_texture_uv(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, texture_type: u32) -> vec3<f32> {\n    let texture_coords_set = material_texture_coord_set(material, texture_type);  \n    let texture_id = material_texture_index(material, texture_type);\n    let uv = vec3<f32>((*pixel_data).uv_set[texture_coords_set], f32(texture_id));\n    return uv;\n} \n\nfn compute_tbn(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>) -> TBN {\n    var n = (*pixel_data).normal;\n    var t = (*pixel_data).tangent.xyz;\n    var b = cross(n,  t) * -(*pixel_data).tangent.w;\n    return TBN(n, t, b);\n    /*\n    var n = normalize((*pixel_data).normal);\n    let s = select(-1f, 1f, n.z >= 0f);\n    let a = -1f / (s + n.z);\n    let b = n.x * n.y * a;\n    let u = vec3(1f + s * n.x * n.x * a, s * b, -s * n.x);\n    let v = vec3(b, s + n.y * n.y * a, -n.y);\n\n    return TBN(n, normalize(u), normalize(v));\n    */\n    /*\n    var b = vec3<f32>(0.0, 1.0, 0.0);\n    let NdotUp = dot((*pixel_data).normal, vec3<f32>(0.0, 1.0, 0.0));\n    if (1.0 - abs(NdotUp) <= MATH_EPSILON)\n    {\n        // Sampling +Y or -Y, so we need a more robust bitangent.\n        if (NdotUp > 0.0)\n        {\n            b = vec3<f32>(0.0, 0.0, 1.0);\n        }\n        else\n        {\n            b = vec3<f32>(0.0, 0.0, -1.0);\n        }\n    }\n    let t = normalize(cross(b, (*pixel_data).normal));\n    b = cross((*pixel_data).normal, t);\n    return TBN((*pixel_data).normal, t, b);\n    //if (has_texture(material, TEXTURE_TYPE_NORMAL)) {  \n    //    let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_NORMAL);\n    //    var uv_dx = dpdx(uv);\n    //    var uv_dy = dpdy(uv);\n    //    if (length(uv_dx) <= 0.01) {\n    //        uv_dx = vec2<f32>(1., 0.);\n    //    }\n    //    if (length(uv_dy) <= 0.01) {\n    //        uv_dy = vec2<f32>(0., 1.);\n    //    }\n    //    let t_temp = (uv_dy.x * dpdx((*pixel_data).world_pos) - uv_dx.x * dpdy((*pixel_data).world_pos)) /\n    //                 (uv_dx.y * uv_dy.x - uv_dy.y * uv_dx.x);\n    //\n    //    t = normalize(t_temp - n * dot(n, t_temp));\n    //    b = cross(n, t);\n    //    \n    //    var ntex = sample_texture(uv).rgb * 2. - vec3<f32>(1.);\n    //    ntex = normalize(ntex);\n    //    n = normalize(mat3x3<f32>(t, b, n) * ntex);\n    //}\n    return TBN(n, t, b);\n    */\n}\n\nfn compute_normal(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>) -> vec3<f32> {\n    let tbn = compute_tbn(material, pixel_data);\n    return tbn.normal;\n}\n\nfn init_material_info_default(info: ptr<function, MaterialInfo>) {\n    (*info).base_color = vec4<f32>(1.);\n    (*info).f0 = vec3<f32>(0.04);\n    (*info).ior = 1.5;\n    (*info).c_diff = vec3<f32>(1.);\n    (*info).perceptual_roughness = 1.;\n    (*info).metallic = 1.;\n    (*info).specular_weight_and_anisotropy_strength = pack2x16float(vec2<f32>(1., 0.));\n    (*info).transmission_factor = 0.;\n    (*info).thickness_factor = 0.;\n    (*info).attenuation_color_and_distance = vec4<f32>(1.,1.,1.,0.);\n    (*info).sheen_color_and_roughness_factor = vec4<f32>(1.,1.,1.,0.);\n    (*info).clear_coat_factor = 0.;\n    (*info).clear_coat_roughness_factor = 0.;\n    (*info).iridescence_ior = 1.3;\n    (*info).iridescence_thickness = 100.;\n    (*info).alpha_roughness = 0.;\n    (*info).f90 = vec3<f32>(1.);\n\n    (*info).f_color = vec4<f32>(0.);\n    (*info).f_emissive = vec3<f32>(0.);\n    (*info).f_diffuse = vec3<f32>(0.);\n    (*info).f_diffuse_ibl = vec3<f32>(0.);\n    (*info).f_specular = vec3<f32>(0.);\n}\n\nfn compute_base_color(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {\n    if(((*material).flags & MATERIAL_FLAGS_SPECULARGLOSSINESS) != 0u) {\n        (*info).base_color = (*material).diffuse_color;\n        if (has_texture(material, TEXTURE_TYPE_DIFFUSE)) {  \n            let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_DIFFUSE);\n            let texture_color = sample_texture(uv);\n            (*info).base_color *= texture_color;\n        }\n    } else if(((*material).flags & MATERIAL_FLAGS_UNLIT) != 0u || ((*material).flags & MATERIAL_FLAGS_METALLICROUGHNESS) != 0u) {\n        (*info).base_color = (*material).base_color;\n        if (has_texture(material, TEXTURE_TYPE_BASE_COLOR)) {  \n            let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_BASE_COLOR);\n            let texture_color = sample_texture(uv);\n            (*info).base_color *= texture_color;\n        }\n    }\n    \n    (*info).base_color *= (*pixel_data).color;\n    if(((*material).flags & MATERIAL_FLAGS_ALPHAMODE_OPAQUE) != 0) {\n        (*info).base_color.a = 1.;\n    }\n}\n\nfn compute_ior(material: ptr<function, Material>, info: ptr<function, MaterialInfo>) {\n    (*info).ior = (*material).ior;\n    (*info).f0 = vec3<f32>(pow(( (*info).ior - 1.) /  ((*info).ior + 1.), 2.));\n}\n\nfn compute_specular_glossiness(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {\n    (*info).f0 = (*material).specular_color.xyz;\n    (*info).perceptual_roughness = (*material).specular_color.w;\n    if (has_texture(material, TEXTURE_TYPE_SPECULAR_GLOSSINESS)) {  \n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_SPECULAR_GLOSSINESS);\n        let texture_color = sample_texture(uv);\n        (*info).f0 *= texture_color.rgb;\n        (*info).perceptual_roughness *= texture_color.a;\n    }\n    (*info).perceptual_roughness = 1. - (*info).perceptual_roughness;\n    (*info).c_diff = (*info).base_color.rgb * (1. - max(max((*info).f0.r, (*info).f0.g), (*info).f0.b));\n}\n\nfn compute_metallic_roughness(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {    \n    (*info).perceptual_roughness = (*material).roughness_factor;\n    (*info).metallic = (*material).metallic_factor;\n    if (has_texture(material, TEXTURE_TYPE_METALLIC_ROUGHNESS)) {        \n        // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n        // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_METALLIC_ROUGHNESS);\n        let texture_color = sample_texture(uv);\n        (*info).perceptual_roughness *= texture_color.g;\n        (*info).metallic *= texture_color.b;\n    }\n    // Achromatic f0 based on IOR.\n    (*info).c_diff = mix((*info).base_color.rgb,  vec3<f32>(0.), (*info).metallic);\n    (*info).f0 = mix((*info).f0, (*info).base_color.rgb, (*info).metallic);\n}\n\nfn compute_sheen(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {   \n    (*info).sheen_color_and_roughness_factor = vec4<f32>(1.,1.,1.,0.);\n\n    //NOT SUPPORTED TILL NOW - need gltf-rs support for KHR_materials_sheen\n}\n\nfn compute_clear_coat(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {   \n    (*info).clear_coat_factor = 0.;\n    (*info).clear_coat_roughness_factor = 0.;\n    (*info).clear_coat_f0 = vec3<f32>(pow(((*info).ior - 1.0) / ((*info).ior + 1.0), 2.0));\n    (*info).clear_coat_f90 = vec3<f32>(1.0);\n    (*info).clear_coat_normal = (*pixel_data).normal;\n    \n    //NOT SUPPORTED TILL NOW - need gltf-rs support for KHR_materials_clearcoat\n}\n\nfn compute_specular(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {   \n    var specular_texture = vec4<f32>(1.0);\n    if (has_texture(material, TEXTURE_TYPE_SPECULAR)) {        \n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_SPECULAR);\n        let texture_color = sample_texture(uv);\n        specular_texture.a = texture_color.a;\n    }\n    if (has_texture(material, TEXTURE_TYPE_SPECULAR_COLOR)) {        \n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_SPECULAR_COLOR);\n        let texture_color = sample_texture(uv);\n        specular_texture = vec4<f32>(texture_color.rgb, specular_texture.a);\n    }\n    let dielectric_specular_f0 = min((*info).f0 * (*material).specular_factors.rgb * specular_texture.rgb, vec3<f32>(1.));\n    let anisotropy_strength = unpack2x16float((*info).specular_weight_and_anisotropy_strength).y;\n    (*info).specular_weight_and_anisotropy_strength = pack2x16float(vec2<f32>((*material).specular_factors.a * specular_texture.a, anisotropy_strength));\n    (*info).f0 = mix(dielectric_specular_f0, (*info).base_color.rgb, (*info).metallic);\n    (*info).c_diff = mix((*info).base_color.rgb, vec3<f32>(0.), (*info).metallic);\n}\n\nfn compute_transmission(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {   \n    (*info).transmission_factor = (*material).transmission_factor;\n    if (has_texture(material, TEXTURE_TYPE_TRANSMISSION)) {        \n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_TRANSMISSION);\n        let texture_color = sample_texture(uv);\n        (*info).transmission_factor *= texture_color.r;\n    }\n}\n\nfn compute_volume(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {   \n    (*info).thickness_factor = (*material).thickness_factor;\n    (*info).attenuation_color_and_distance = (*material).attenuation_color_and_distance;\n    if (has_texture(material, TEXTURE_TYPE_THICKNESS)) {        \n        let uv = material_texture_uv(material, pixel_data, TEXTURE_TYPE_THICKNESS);\n        let texture_color = sample_texture(uv);\n        (*info).thickness_factor *= texture_color.g;\n    }\n}\n\nfn compute_iridescence(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) {  \n    (*info).iridescence_factor = 0.;\n    (*info).iridescence_ior = (*info).ior;\n    (*info).iridescence_thickness = 0.;\n\n    //NOT SUPPORTED TILL NOW - need gltf-rs support for KHR_materials_iridescence \n}\n\nfn compute_anisotropy(material: ptr<function, Material>, pixel_data: ptr<function, PixelData>, info: ptr<function, MaterialInfo>) { \n    let specular_weight = unpack2x16float((*info).specular_weight_and_anisotropy_strength).x;\n    let tbn = compute_tbn(material, pixel_data);\n    (*info).anisotropicT = tbn.tangent;\n    (*info).anisotropicB = tbn.binormal;\n    (*info).specular_weight_and_anisotropy_strength = pack2x16float(vec2<f32>(specular_weight, 0.));\n\n    //NOT SUPPORTED TILL NOW - need gltf-rs support for KHR_materials_anisotropy\n}\n// Inspired from https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n// XYZ to sRGB color space\nconst XYZ_TO_REC709: mat3x3<f32> = mat3x3<f32>(\n     3.2404542, -0.9692660,  0.0556434,\n    -1.5371385,  1.8760108, -0.2040259,\n    -0.4985314,  0.0415560,  1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nfn fresnel0_to_ior(fresnel0: vec3<f32>) -> vec3<f32> {\n    let sqrtF0 = sqrt(fresnel0);\n    return (vec3<f32> (1.0) + sqrtF0) / (vec3<f32> (1.0) - sqrtF0);\n}\n\n// Conversion FO/IOR\nfn ior_to_fresnel0_vec3(transmittedIor: vec3<f32>, incidentIor: f32) -> vec3<f32>{\n    let ior = (transmittedIor - vec3<f32>(incidentIor)) / (transmittedIor + vec3<f32>(incidentIor));\n    return ior * ior;\n}\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nfn ior_to_fresnel0_f32(transmittedIor: f32, incidentIor: f32) -> f32 {\n    let ior = (transmittedIor - incidentIor) / (transmittedIor + incidentIor);\n    return ior * ior;\n}\n\nfn apply_ior_to_roughness(roughness: f32, ior: f32) -> f32 {\n    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n    // an IOR of 1.5 results in the default amount of microfacet refraction.\n    return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n}\n\nfn f_schlick_f32(f0: f32, f90: f32, VdotH: f32) -> f32 {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn f_schlick_vec3_f32(f0: vec3<f32>, f90: f32, VdotH: f32) -> vec3<f32>\n{\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = x * x2 * x2;\n    return f0 + (f90 - f0) * x5;\n}\n\nfn f_schlick_vec3_vec3(f0: vec3<f32>, f90: vec3<f32>, VdotH: f32) -> vec3<f32>\n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\nfn schlick_to_f0_vec3(f: vec3<f32>, f90: vec3<f32>, VdotH: f32) -> vec3<f32> {\n    let x = clamp(1.0 - VdotH, 0.0, 1.0);\n    let x2 = x * x;\n    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);\n    let r = (f - (f90 * x5));\n    return (r / (1.0 - x5));\n}\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\n// see Real-Time Rendering. Page 331 to 336.\n// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\nfn V_GGX(NdotL: f32, NdotV: f32, alphaRoughness: f32) -> f32 {\n    let alphaRoughnessSq = alphaRoughness * alphaRoughness;\n\n    let GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n    let GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);\n\n    let GGX = GGXV + GGXL;\n    return select(0., 0.5 / GGX, GGX > 0.0);\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfn D_GGX(NdotH: f32, alphaRoughness: f32) -> f32 {\n    let alphaRoughnessSq = alphaRoughness * alphaRoughness;\n    let f = (NdotH * NdotH) * (alphaRoughnessSq - 1.0) + 1.0;\n    return alphaRoughnessSq / (MATH_PI * f * f);\n}\n\n// GGX Mask/Shadowing Anisotropic (Same as Babylon.js - smithVisibility_GGXCorrelated_Anisotropic)\n// Heitz http://jcgt.org/published/0003/02/03/paper.pdf\nfn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32, at: f32, ab: f32) -> f32 {\n    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\n    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\n    let v = 0.5 / (GGXV + GGXL);\n    return clamp(v, 0.0, 1.0);\n}\n\n// GGX Distribution Anisotropic (Same as Babylon.js)\n// https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\nfn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, anisotropy: f32, at: f32, ab: f32) -> f32 {\n    let a2 = at * ab;\n    let f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\n    let w2 = a2 / dot(f, f);\n    return a2 * w2 * w2 / MATH_PI;\n}\n\n// Estevez and Kulla http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\nfn D_Charlie(sheenRoughness: f32, NdotH: f32) -> f32 {\n    let s = max(sheenRoughness, 0.000001); //clamp (0,1)\n    let alphaG = s * s;\n    let invR = 1.0 / alphaG;\n    let cos2h = NdotH * NdotH;\n    let sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * MATH_PI);\n}\n\nfn lambda_sheen_numeric_helper(x: f32, alphaG: f32) -> f32 {\n    let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n    let a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n    let b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n    let c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n    let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n    let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\nfn lambda_sheen(cosTheta: f32, alphaG: f32) -> f32 {\n    if (abs(cosTheta) < 0.5)\n    {\n        return exp(lambda_sheen_numeric_helper(cosTheta, alphaG));\n    }\n    else\n    {\n        return exp(2.0 * lambda_sheen_numeric_helper(0.5, alphaG) - lambda_sheen_numeric_helper(1.0 - cosTheta, alphaG));\n    }\n}\n\nfn V_Sheen(NdotL: f32, NdotV: f32, sheenRoughness: f32) -> f32 {\n    let s = max(sheenRoughness, 0.000001); //clamp (0,1)\n    let alphaG = sheenRoughness * sheenRoughness;\n\n    return clamp(1.0 / ((1.0 + lambda_sheen(NdotV, alphaG) + lambda_sheen(NdotL, alphaG)) *\n        (4.0 * NdotV * NdotL)), 0.0, 1.0);\n}\n\nfn sheen_LUT(uv: vec2<f32>) -> vec4<f32> {\n    let tl = vec4<f32>(1.0,1.0,1.0,1.);\n    let tr = vec4<f32>(0.0,0.0,0.0,1.);\n    let bl = vec4<f32>(1.0,1.0,1.0,1.);\n    let br = vec4<f32>(0.5,0.5,0.5,1.);\n    return mix(mix(tr,tr,uv.x),mix(bl,br,uv.x),uv.y);\n}\n\nfn albedo_sheen_scaling_LUT(NdotV: f32, sheenRoughnessFactor: f32) -> f32\n{\n    return sheen_LUT(vec2<f32>(NdotV, sheenRoughnessFactor)).r;\n}\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nfn eval_sensitivity(OPD: f32, shift: vec3<f32>) -> vec3<f32> {\n    let phase = 2.0 * MATH_PI * OPD * 1.0e-9;\n    let val = vec3<f32>(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    let pos = vec3<f32>(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    let v = vec3<f32>(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\n    let p = phase*phase;\n    var xyz = val * sqrt(2.0 * MATH_PI * v) * cos(pos * phase + shift) * exp(-p * v);\n    xyz.x += 9.7470e-14 * sqrt(2.0 * MATH_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * p);\n    xyz /= 1.0685e-7;\n\n    let srgb = XYZ_TO_REC709 * xyz;\n    return srgb;\n}\n\nfn eval_iridescence(outsideIOR: f32, eta2: f32, cosTheta1: f32, thinFilmThickness:f32, baseF0: vec3<f32>) -> vec3<f32> {\n    var I = vec3<f32>(1.);\n\n    // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n    let iridescenceIor = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n    // Evaluate the cosTheta on the base layer (Snell law)\n    let ior = (outsideIOR / iridescenceIor);\n    let sinTheta2Sq = ior * ior * (1.0 - (cosTheta1 * cosTheta1));\n\n    // Handle TIR:\n    let cosTheta2Sq = 1.0 - sinTheta2Sq;\n    if (cosTheta2Sq < 0.0) {\n        return I;\n    }\n\n    let cosTheta2 = sqrt(cosTheta2Sq);\n\n    // First interface\n    let R0 = ior_to_fresnel0_f32(iridescenceIor, outsideIOR);\n    let R12 = f_schlick_f32(R0, 1.0, cosTheta1);\n    let T121 = 1.0 - R12;\n    var phi12 = 0.0;\n    if (iridescenceIor < outsideIOR) { phi12 = MATH_PI; }\n    let phi21 = MATH_PI - phi12;\n\n    // Second interface\n    let baseIOR = fresnel0_to_ior(clamp(baseF0, vec3<f32>(0.0), vec3<f32>(0.9999))); // guard against 1.0\n    let R1 = ior_to_fresnel0_vec3(baseIOR, iridescenceIor);\n    let R23 = f_schlick_vec3_f32(R1, 1.0, cosTheta2);\n    var phi23 = vec3<f32>(0.0);\n    if (baseIOR[0] < iridescenceIor) { phi23[0] = MATH_PI; }\n    if (baseIOR[1] < iridescenceIor) { phi23[1] = MATH_PI; }\n    if (baseIOR[2] < iridescenceIor) { phi23[2] = MATH_PI; }\n\n    // Phase shift\n    let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n    let phi = vec3<f32>(phi21) + phi23;\n\n    //// Compound terms\n    let R123 = clamp(R12 * R23, vec3<f32>(1e-5), vec3<f32>(0.9999));\n    let r123 = sqrt(R123);\n    let Rs = (T121 * T121) * R23 / (vec3<f32>(1.0) - R123);\n\n    //// Reflectance term for m = 0 (DC term amplitude)\n    I = R12 + Rs;\n\n    // Reflectance term for m > 0 (pairs of diracs)\n    var Cm = Rs - T121;\n    for (var m = 1; m <= 2; m++)\n    {\n        Cm *= r123;\n        let Sm = 2.0 * eval_sensitivity(f32(m) * OPD, f32(m) * phi);\n        I += Cm * Sm;\n    }\n\n    // Since out of gamut colors might be produced, negative color values are clamped to 0.\n    return max(I, vec3<f32>(0.0));\n}\n\nfn BRDF_lambertian_iridescence(f0: vec3<f32>, f90: vec3<f32>, iridescenceFresnel: vec3<f32>, iridescenceFactor: f32, diffuseColor: vec3<f32>, specularWeight: f32, VdotH: f32) -> vec3<f32> {\n    // Use the maximum component of the iridescence Fresnel color\n    // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF\n    let iridescenceFresnelMax = vec3<f32>(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));\n\n    let schlickFresnel = f_schlick_vec3_vec3(f0, f90, VdotH);\n\n    // Blend default specular Fresnel with iridescence Fresnel\n    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);\n\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * F) * (diffuseColor / MATH_PI);\n}\n\nfn BRDF_specular_GGX_anisotropy(f0: vec3<f32>, f90: vec3<f32>, alphaRoughness: f32, anisotropy: f32, n: vec3<f32>, v: vec3<f32>, l: vec3<f32>, h: vec3<f32>, t: vec3<f32>, b: vec3<f32>) -> vec3<f32> {\n    // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab = clamp(alphaRoughness, 0.001, 1.0);\n\n    let NdotL = clamp(dot(n, l), 0.0, 1.0);\n    let NdotH = clamp(dot(n, h), 0.001, 1.0);\n    let NdotV = dot(n, v);\n    let VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    let V = V_GGX_anisotropic(NdotL, NdotV, dot(b, v), dot(t, v), dot(t, l), dot(b, l), at, ab);\n    let D = D_GGX_anisotropic(NdotH, dot(t, h), dot(b, h), anisotropy, at, ab);\n\n    let F = f_schlick_vec3_vec3(f0, f90, VdotH);\n    return F * V * D;\n}\n\nfn BRDF_specular_GGX_iridescence(f0: vec3<f32>, f90: vec3<f32>, iridescenceFresnel: vec3<f32>, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3<f32> {\n    let F = mix(f_schlick_vec3_vec3(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);\n    let Vis = V_GGX(NdotL, NdotV, alphaRoughness);\n    let D = D_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\nfn BRDF_lambertian(f0: vec3<f32>, f90: vec3<f32>, diffuseColor: vec3<f32>, specularWeight: f32, VdotH: f32) -> vec3<f32> {\n    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    return (1.0 - specularWeight * f_schlick_vec3_vec3(f0, f90, VdotH)) * (diffuseColor / MATH_PI);\n}\n\nfn BRDF_specular_GGX(f0: vec3<f32>, f90: vec3<f32>, alphaRoughness: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3<f32> {\n    let F = f_schlick_vec3_vec3(f0, f90, VdotH);\n    let Vis = V_GGX(NdotL, NdotV, alphaRoughness);\n    let D = D_GGX(NdotH, alphaRoughness);\n\n    return specularWeight * F * Vis * D;\n}\n\nfn BRDF_specular_sheen(sheenColor: vec3<f32>, sheenRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3<f32> {\n    let sheenDistribution = D_Charlie(sheenRoughness, NdotH);\n    let sheenVisibility = V_Sheen(NdotL, NdotV, sheenRoughness);\n    return sheenColor * sheenDistribution * sheenVisibility;\n}\n\nfn get_punctual_radiance_sheen(sheenColor: vec3<f32>, sheenRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3<f32> {\n    return NdotL * BRDF_specular_sheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH);\n}\n\nfn get_punctual_radiance_clearcoat(clearcoatNormal: vec3<f32>, v: vec3<f32>, l: vec3<f32>, h: vec3<f32>, VdotH: f32, f0: vec3<f32>, f90: vec3<f32>, clearcoatRoughness: f32) -> vec3<f32> {\n    let NdotL = clamped_dot(clearcoatNormal, l);\n    let NdotV = clamped_dot(clearcoatNormal, v);\n    let NdotH = clamped_dot(clearcoatNormal, h);\n    return NdotL * BRDF_specular_GGX(f0, f90, clearcoatRoughness * clearcoatRoughness, 1.0, VdotH, NdotL, NdotV, NdotH);\n}\n\nfn get_punctual_radiance_transmission(normal: vec3<f32>, view: vec3<f32>, pointToLight: vec3<f32>, alphaRoughness: f32, f0: vec3<f32>, f90: vec3<f32>, baseColor: vec3<f32>, ior: f32) -> vec3<f32> {\n    let transmissionRougness = apply_ior_to_roughness(alphaRoughness, ior);\n\n    let n = normalize(normal);           // Outward direction of surface point\n    let v = normalize(view);             // Direction from surface point to view\n    let l = normalize(pointToLight);\n    let l_mirror = normalize(l + 2.0*n*dot(-l, n));     // Mirror light reflection vector on surface\n    let h = normalize(l_mirror + v);            // Halfway vector between transmission light vector and v\n\n    let D = D_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRougness);\n    let F = f_schlick_vec3_vec3(f0, f90, clamp(dot(v, h), 0.0, 1.0));\n    let Vis = V_GGX(clamp(dot(n, l_mirror), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRougness);\n\n    // Transmission BTDF\n    return (1.0 - F) * baseColor * D * Vis;\n}\n\nfn get_range_attenuation(range: f32, distance: f32) -> f32 {\n    if (range <= 0.0)\n    {\n        // negative range means unlimited\n        return 1.0 / pow(distance, 2.0);\n    }\n    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\nfn get_spot_attenuation(pointToLight: vec3<f32>, spotDirection: vec3<f32>, outerConeCos: f32, innerConeCos: f32) -> f32 {\n    let actualCos = dot(normalize(spotDirection), normalize(-pointToLight));\n    if (actualCos > outerConeCos)\n    {\n        if (actualCos < innerConeCos)\n        {\n            let angularAttenuation = (actualCos - outerConeCos) / (innerConeCos - outerConeCos);\n            return angularAttenuation * angularAttenuation;\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nfn get_light_intensity(light: ptr<function, LightData>, pointToLight: vec3<f32>) -> vec3<f32> {\n    var rangeAttenuation = 1.0;\n    var spotAttenuation = 1.0;\n\n    if ((*light).light_type != LIGHT_TYPE_DIRECTIONAL)\n    {\n        rangeAttenuation = get_range_attenuation((*light).range, length(pointToLight));\n    }\n    if ((*light).light_type == LIGHT_TYPE_SPOT)\n    {\n        spotAttenuation = get_spot_attenuation(pointToLight, (*light).direction, (*light).outer_cone_angle, (*light).inner_cone_angle);\n    }\n    return rangeAttenuation * spotAttenuation * (*light).intensity * (*light).color;\n}\n\nfn get_volume_transmission_ray(n: vec3<f32>, v: vec3<f32>, thickness: f32, ior: f32, scale: f32) -> vec3<f32> {\n    // Direction of refracted light.\n    let refractionVector = refract(-v, normalize(n), 1.0 / ior);\n    // The thickness is specified in local space.\n    return normalize(refractionVector) * thickness * scale;\n}\n\n// Compute attenuated light as it travels through a volume.\nfn apply_volume_attenuation(radiance: vec3<f32>, transmissionDistance: f32, attenuationColor: vec3<f32>, attenuationDistance: f32) -> vec3<f32> {\n    if (attenuationDistance == 0.0)\n    {\n        // Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n        return radiance;\n    }\n    else\n    {\n        // Compute light attenuation using Beer's law.\n        let attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n        let transmittance = exp(-attenuationCoefficient * transmissionDistance); // Beer's law\n        return transmittance * radiance;\n    }\n}\n\n//Inspired from glTF-Sample-Viewer\nfn compute_color_from_material(material_id: u32, pixel_data: ptr<function, PixelData>) -> MaterialInfo {\n    var material = materials.data[material_id];\n\n    let v = normalize(matrix_row(constant_data.view, 2u).xyz - (*pixel_data).world_pos);\n    let tbn = compute_tbn(&material, pixel_data);\n\n    let NdotV = clamped_dot(tbn.normal,v);\n    let TdotV = clamped_dot(tbn.tangent,v);\n    let BdotV = clamped_dot(tbn.binormal,v);\n\n    var material_info: MaterialInfo;\n\n    init_material_info_default(&material_info);\n    compute_base_color(&material, pixel_data, &material_info);\n\n    if((material.flags & MATERIAL_FLAGS_IOR) != 0u) {\n        compute_ior(&material, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_SPECULARGLOSSINESS) != 0u) {\n        compute_specular_glossiness(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_METALLICROUGHNESS) != 0u) {\n        compute_metallic_roughness(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_SHEEN) != 0u) {\n        compute_sheen(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_CLEARCOAT) != 0u) {\n        compute_clear_coat(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_SPECULAR) != 0u) {\n        compute_specular(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_TRANSMISSION) != 0u) {\n        compute_transmission(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_VOLUME) != 0u) {\n        compute_volume(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_IRIDESCENCE) != 0u) {\n        compute_iridescence(&material, pixel_data, &material_info);\n    }\n    if((material.flags & MATERIAL_FLAGS_ANISOTROPY) != 0u) {\n        compute_anisotropy(&material, pixel_data, &material_info);\n    }\n\n    material_info.perceptual_roughness = clamp(material_info.perceptual_roughness, 0.0, 1.0);\n    material_info.metallic = clamp(material_info.metallic, 0.0, 1.0);\n    \n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness.\n    material_info.alpha_roughness = material_info.perceptual_roughness * material_info.perceptual_roughness;\n\n    // Compute reflectance.\n    let reflectance = max(max(material_info.f0.r, material_info.f0.g), material_info.f0.b);\n    \n    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n    material_info.f90 = vec3<f32>(1.);\n\n    // LIGHTING\n    var f_specular = vec3<f32>(0.0);\n    var f_diffuse = vec3<f32>(0.0);\n    var f_emissive = vec3<f32>(0.0);\n    var f_clearcoat = vec3<f32>(0.0);\n    var f_sheen = vec3<f32>(0.0);\n    var f_transmission = vec3<f32>(0.0);\n\n    var albedo_sheen_scaling = 1.0;\n\n    var iridescence_fresnel = vec3<f32>(0.);\n    var iridescence_f0 = vec3<f32>(0.);\n    if((material.flags & MATERIAL_FLAGS_IRIDESCENCE) != 0u) {\n        iridescence_fresnel = eval_iridescence(1., material_info.iridescence_ior, NdotV, material_info.iridescence_thickness, material_info.f0);\n        iridescence_f0 = schlick_to_f0_vec3(iridescence_fresnel, vec3<f32>(1.), NdotV);\n        if(material_info.iridescence_thickness == 0.) { material_info.iridescence_factor = 0.; }\n    }\n     \n    // TODO - Calculate lighting contribution from image based lighting source (IBL)\n    \n    var f_diffuse_ibl = f_diffuse;\n    var f_specular_ibl = f_specular;\n    var f_sheen_ibl = f_sheen;\n    var f_clearcoat_ibl = f_clearcoat;\n    f_diffuse = material_info.base_color.rgb;\n    f_specular = vec3<f32>(0.0);\n    f_sheen = vec3<f32>(0.0);\n    f_clearcoat = vec3<f32>(0.0);\n   \n    let num_lights = arrayLength(&lights.data);\n    let i = hash(constant_data.frame_index) % num_lights;\n    \n    var light = lights.data[i];\n    if (light.light_type != LIGHT_TYPE_INVALID) { \n        f_diffuse = vec3<f32>(0.0);\n        var pointToLight: vec3<f32>;\n        if (light.light_type != LIGHT_TYPE_DIRECTIONAL) { \n            pointToLight = light.position - (*pixel_data).world_pos;\n        } else {\n            pointToLight = -light.direction;\n        }\n            \n        // BSTF\n        var l = normalize(pointToLight);   // Direction from surface point to light\n        let h = normalize(l + v);          // Direction of the vector between l and v, called halfway vector\n        let NdotL = clamped_dot(tbn.normal, l);\n        let NdotH = clamped_dot(tbn.normal, h);\n        let NdotV = clamped_dot(tbn.normal, v);\n        let LdotH = clamped_dot(l, h);\n        let VdotH = clamped_dot(v, h);\n        if (NdotL > 0.0 || NdotV > 0.0)\n        {\n            // Calculation of analytical light\n            let intensity = get_light_intensity(&light, pointToLight);\n            let specular_weight_and_anisotropy_strength = unpack2x16float(material_info.specular_weight_and_anisotropy_strength);\n            let specular_weight = specular_weight_and_anisotropy_strength.x;\n            if((material.flags & MATERIAL_FLAGS_IRIDESCENCE) != 0u) {\n                f_diffuse += intensity * NdotL *  BRDF_lambertian_iridescence(material_info.f0, material_info.f90, iridescence_fresnel, material_info.iridescence_factor, material_info.c_diff, specular_weight, VdotH);\n                f_specular += intensity * NdotL * BRDF_specular_GGX_iridescence(material_info.f0, material_info.f90, iridescence_fresnel, material_info.alpha_roughness,  material_info.iridescence_factor, specular_weight, VdotH, NdotL, NdotV, NdotH);\n            }\n            else if((material.flags & MATERIAL_FLAGS_ANISOTROPY) != 0u) {\n                let anisotropy_strength = specular_weight_and_anisotropy_strength.y;\n                f_diffuse += intensity * NdotL *  BRDF_lambertian(material_info.f0, material_info.f90, material_info.c_diff, specular_weight, VdotH);\n                f_specular += intensity * NdotL * BRDF_specular_GGX_anisotropy(material_info.f0, material_info.f90, material_info.alpha_roughness, anisotropy_strength, tbn.normal, v, l, h, material_info.anisotropicT, material_info.anisotropicB);\n            } else {\n                f_diffuse += intensity * NdotL *  BRDF_lambertian(material_info.f0, material_info.f90, material_info.c_diff, specular_weight, VdotH);\n                f_specular += intensity * NdotL * BRDF_specular_GGX(material_info.f0, material_info.f90, material_info.alpha_roughness, specular_weight, VdotH, NdotL, NdotV, NdotH);\n            }\n            \n            if((material.flags & MATERIAL_FLAGS_SHEEN) != 0u) {\n                f_sheen += intensity * get_punctual_radiance_sheen(material_info.sheen_color_and_roughness_factor.rgb, material_info.sheen_color_and_roughness_factor.w, NdotL, NdotV, NdotH);\n                let c = max(max(material_info.sheen_color_and_roughness_factor.r, material_info.sheen_color_and_roughness_factor.g), material_info.sheen_color_and_roughness_factor.b);\n                albedo_sheen_scaling = min(1.0 - c * albedo_sheen_scaling_LUT(NdotV, material_info.sheen_color_and_roughness_factor.w),\n                    1.0 - c * albedo_sheen_scaling_LUT(NdotL, material_info.sheen_color_and_roughness_factor.w));\n            }\n            \n            if((material.flags & MATERIAL_FLAGS_CLEARCOAT) != 0u) {\n                f_clearcoat += intensity * get_punctual_radiance_clearcoat(material_info.clear_coat_normal, v, l, h, VdotH,\n                    material_info.clear_coat_f0, material_info.clear_coat_f90, material_info.clear_coat_roughness_factor);\n            }\n        }\n        \n        // BDTF\n        if((material.flags & MATERIAL_FLAGS_TRANSMISSION) != 0u) {\n            // If the light ray travels through the geometry, use the point it exits the geometry again.\n            // That will change the angle to the light source, if the material refracts the light ray.\n            let transmission_ray = get_volume_transmission_ray(tbn.normal, v, material_info.thickness_factor, material_info.ior, (*pixel_data).mesh_scale);\n            pointToLight -= transmission_ray;\n            l = normalize(pointToLight);\n            let intensity = get_light_intensity(&light, pointToLight);\n            var transmitted_light = intensity * get_punctual_radiance_transmission(tbn.normal, v, l, material_info.alpha_roughness, material_info.f0, material_info.f90, material_info.c_diff, material_info.ior);\n        \n            if((material.flags & MATERIAL_FLAGS_VOLUME) != 0u) {\n                transmitted_light = apply_volume_attenuation(transmitted_light, length(transmission_ray), material_info.attenuation_color_and_distance.rgb, material_info.attenuation_color_and_distance.w);\n            }\n            f_transmission += transmitted_light;\n        }\n    }\n    \n    f_emissive = material.emissive_color.rgb * material.emissive_strength;\n    if (has_texture(&material, TEXTURE_TYPE_EMISSIVE)) {  \n      let uv = material_texture_uv(&material, pixel_data, TEXTURE_TYPE_EMISSIVE);\n      let texture_color = sample_texture(uv);\n      f_emissive *= texture_color.rgb;\n    }\n\n    //Layer blending\n\n    var clearcoatFactor = 0.0;\n    var clearcoatFresnel = vec3(0.);\n    var diffuse = vec3<f32>(0.0);\n    var specular = vec3<f32>(0.0);\n    var sheen = vec3<f32>(0.0);\n    var clearcoat = vec3<f32>(0.0);\n   \n    var ao = 1.0;\n    if (has_texture(&material, TEXTURE_TYPE_OCCLUSION)) {  \n        let uv = material_texture_uv(&material, pixel_data, TEXTURE_TYPE_OCCLUSION);\n        let texture_color = sample_texture(uv);\n        ao = ao * texture_color.r;\n        diffuse = f_diffuse + mix(f_diffuse_ibl, f_diffuse_ibl * ao, material.occlusion_strength);\n        // apply ambient occlusion to all lighting that is not punctual\n        specular = f_specular + mix(f_specular_ibl, f_specular_ibl * ao, material.occlusion_strength);\n        sheen = f_sheen + mix(f_sheen_ibl, f_sheen_ibl * ao, material.occlusion_strength);\n        clearcoat = f_clearcoat + mix(f_clearcoat_ibl, f_clearcoat_ibl * ao, material.occlusion_strength);\n    }\n    else {\n        diffuse = f_diffuse_ibl + f_diffuse;\n        specular = f_specular_ibl + f_specular;\n        sheen = f_sheen_ibl + f_sheen;\n        clearcoat = f_clearcoat_ibl + f_clearcoat;\n    }\n    \n    if((material.flags & MATERIAL_FLAGS_CLEARCOAT) != 0u) {\n        clearcoatFactor = material_info.clear_coat_factor;\n        clearcoatFresnel = f_schlick_vec3_vec3(material_info.clear_coat_f0, material_info.clear_coat_f90, clamped_dot(material_info.clear_coat_normal, v));\n        clearcoat *= clearcoatFactor;\n    }\n    \n    if((material.flags & MATERIAL_FLAGS_TRANSMISSION) != 0u) {\n        diffuse = mix(diffuse, f_transmission, material_info.transmission_factor);\n    }\n\n    var color = vec3<f32>(0.);\n    if((material.flags & MATERIAL_FLAGS_UNLIT) != 0u) {\n        color = material_info.base_color.rgb;\n    } else {\n        color = f_emissive + diffuse + specular;\n        color = sheen + color * albedo_sheen_scaling;\n        color = color * (1.0 - clearcoatFactor * clearcoatFresnel) + clearcoat;\n    }\n\n    material_info.f_color = vec4<f32>(color, material_info.base_color.a);\n    material_info.f_emissive = f_emissive;\n    material_info.f_diffuse = f_diffuse;\n    material_info.f_diffuse_ibl = f_diffuse_ibl;\n    material_info.f_specular = f_specular;\n    return material_info;\n}\n// Need constant_data, meshlets, meshes, indices, runtime_vertices, vertices_attributes\n\nfn visibility_to_gbuffer(visibility_id: u32, hit_point: vec3<f32>) -> PixelData \n{     \n    var uv_set: array<vec2<f32>, 4>;\n    var normal = vec3<f32>(0.);\n    var tangent = vec4<f32>(0.);\n    var color = vec4<f32>(1.);\n\n    let meshlet_id = (visibility_id >> 8u) - 1u; \n    let primitive_id = visibility_id & 255u;\n    \n    let meshlet = &meshlets.data[meshlet_id];\n    let index_offset = (*meshlet).indices_offset + (primitive_id * 3u);\n\n    let mesh_id = u32((*meshlet).mesh_index);\n    let mesh = &meshes.data[mesh_id];\n    let material_id = u32((*mesh).material_index);\n    let position_offset = (*mesh).vertices_position_offset;\n    let attributes_offset = (*mesh).vertices_attribute_offset;\n    let vertex_layout = (*mesh).flags_and_vertices_attribute_layout;\n    let orientation = (*mesh).orientation;\n    let scale = (*mesh).scale;\n    let vertex_attribute_stride = vertex_layout_stride(vertex_layout);   \n    let offset_color = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_COLOR);\n    let offset_normal = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_NORMAL);\n    let offset_tangent = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_TANGENT);\n    let offset_uv0 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV1);\n    let offset_uv1 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV2);\n    let offset_uv2 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV3);\n    let offset_uv3 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV4); \n\n    let vert_indices = vec3<u32>(indices.data[index_offset], indices.data[index_offset + 1u], indices.data[index_offset + 2u]);\n    let attr_indices = vec3<u32>(attributes_offset + vert_indices.x * vertex_attribute_stride, \n                                 attributes_offset + vert_indices.y * vertex_attribute_stride,\n                                 attributes_offset + vert_indices.z * vertex_attribute_stride);\n    \n    let p1 = runtime_vertices.data[vert_indices.x + position_offset].world_pos;\n    let p2 = runtime_vertices.data[vert_indices.y + position_offset].world_pos;\n    let p3 = runtime_vertices.data[vert_indices.z + position_offset].world_pos;\n    \n    let barycentrics = compute_barycentrics_3d(p1,p2,p3,hit_point); \n\n    if (offset_color >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_color)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_color)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_color)];\n        let c1 = unpack_unorm_to_4_f32(a1);\n        let c2 = unpack_unorm_to_4_f32(a2);\n        let c3 = unpack_unorm_to_4_f32(a3);\n        color *= barycentrics.x * c1 + barycentrics.y * c2 + barycentrics.z * c3;    \n    }\n    if (offset_normal >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_normal)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_normal)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_normal)];\n        let n1 = unpack_snorm_to_3_f32(a1);\n        let n2 = unpack_snorm_to_3_f32(a2);\n        let n3 = unpack_snorm_to_3_f32(a3);\n        normal = barycentrics.x * n1 + barycentrics.y * n2 + barycentrics.z * n3;\n        normal = rotate_vector(normal, orientation); \n        normal = normal;\n    }\n    if (offset_tangent >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_tangent)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_tangent)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_tangent)];\n        let t1 = unpack_snorm_to_4_f32(a1);\n        let t2 = unpack_snorm_to_4_f32(a2);\n        let t3 = unpack_snorm_to_4_f32(a3);\n        let t = barycentrics.x * t1 + barycentrics.y * t2 + barycentrics.z * t3;\n        let rot_t = rotate_vector(t.xyz, orientation); \n        tangent = vec4<f32>(rot_t, t.w);\n    } else {\n        var n = normalize(normal);\n        let s = select(-1., 1., n.z >= 0.);\n        let a = -1. / (s + n.z);\n        let b = n.x * n.y * a;\n        tangent = vec4<f32>(1f + s * n.x * n.x * a, s * b, -s * n.x, 1.);\n    }\n    if(offset_uv0 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv0)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv0)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv0)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[0] = barycentrics.x * uv1 + barycentrics.y * uv2 + barycentrics.z * uv3;\n    }\n    if(offset_uv1 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv1)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv1)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv1)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[1] = barycentrics.x * uv1 + barycentrics.y * uv2 + barycentrics.z * uv3;\n    }\n    if(offset_uv2 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv2)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv2)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv2)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[2] = barycentrics.x * uv1 + barycentrics.y * uv2 + barycentrics.z * uv3;\n    }\n    if(offset_uv3 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv3)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv3)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv3)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[3] = barycentrics.x * uv1 + barycentrics.y * uv2 + barycentrics.z * uv3;\n    }    \n\n    return PixelData(hit_point, material_id, color, normal, scale.x, tangent, uv_set);\n}\nconst GAMMA: f32 = 2.2;\nconst INV_GAMMA: f32 = 1.0 / GAMMA;\n\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst ACESOutputMat: mat3x3<f32> = mat3x3<f32>(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n);\n\nfn Uncharted2ToneMapping(color: vec3<f32>) -> vec3<f32> {\n\tlet A = 0.15;\n\tlet B = 0.50;\n\tlet C = 0.10;\n\tlet D = 0.20;\n\tlet E = 0.02;\n\tlet F = 0.30;\n\tlet W = 11.2;\n\tlet exposure = 2.;\n\tvar result = color * exposure;\n\tresult = ((result * (A * result + C * B) + D * E) / (result * (A * result + B) + D * F)) - E / F;\n\tlet white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tresult /= white;\n\tresult = pow(result, vec3<f32>(1. / GAMMA));\n\treturn result;\n}\n\nfn tonemap_ACES_Narkowicz(color: vec3<f32>) -> vec3<f32> {\n    let A = 2.51;\n    let B = 0.03;\n    let C = 2.43;\n    let D = 0.59;\n    let E = 0.14;\n    return clamp((color * (A * color + vec3<f32>(B))) / (color * (C * color + vec3<f32>(D)) + vec3<f32>(E)), vec3<f32>(0.0), vec3<f32>(1.0));\n}\n\n// ACES filmic tone map approximation\n// see https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nfn RRTAndODTFit(color: vec3<f32>) -> vec3<f32> {\n    let a = color * (color + vec3<f32>(0.0245786)) - vec3<f32>(0.000090537);\n    let b = color * (0.983729 * color + vec3<f32>(0.4329510)) + vec3<f32>(0.238081);\n    return a / b;\n}\n\nfn tonemap_ACES_Hill(color: vec3<f32>) -> vec3<f32> {\n   var c = ACESOutputMat * RRTAndODTFit(color);\n   return clamp(c, vec3<f32>(0.0), vec3<f32>(1.0));\n}\n\n\n\n// 0-1 linear  from  0-1 sRGB gamma\nfn linear_from_gamma_rgb(srgb: vec3<f32>) -> vec3<f32> {\n    let cutoff = srgb < vec3<f32>(0.04045);\n    let lower = srgb / vec3<f32>(12.92);\n    let higher = pow((srgb + vec3<f32>(0.055)) / vec3<f32>(1.055), vec3<f32>(2.4));\n    return select(higher, lower, cutoff);\n}\n\n// 0-1 sRGB gamma  from  0-1 linear\nfn gamma_from_linear_rgb(rgb: vec3<f32>) -> vec3<f32> {\n    let cutoff = rgb < vec3<f32>(0.0031308);\n    let lower = rgb * vec3<f32>(12.92);\n    let higher = vec3<f32>(1.055) * pow(rgb, vec3<f32>(1.0 / 2.4)) - vec3<f32>(0.055);\n    return select(higher, lower, cutoff);\n}\n\n// 0-1 sRGBA gamma  from  0-1 linear\nfn gamma_from_linear_rgba(linear_rgba: vec4<f32>) -> vec4<f32> {\n    return vec4<f32>(gamma_from_linear_rgb(linear_rgba.rgb), linear_rgba.a);\n}\n\n// [u8; 4] SRGB as u32 -> [r, g, b, a] in 0.-1\nfn unpack_color(color: u32) -> vec4<f32> {\n    return vec4<f32>(\n        f32(color & 255u),\n        f32((color >> 8u) & 255u),\n        f32((color >> 16u) & 255u),\n        f32((color >> 24u) & 255u),\n    ) / 255.;\n}\n\n// linear to sRGB approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nfn linearTosRGB(color: vec3<f32>) -> vec3<f32>\n{\n    return pow(color, vec3(INV_GAMMA));\n}\n\n// sRGB to linear approximation\n// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nfn sRGBToLinear(srgbIn: vec3<f32>) -> vec3<f32>\n{\n    return vec3<f32>(pow(srgbIn.xyz, vec3<f32>(GAMMA)));\n}\n\n\nfn read_value_from_debug_data_texture(i: ptr<function, u32>) -> f32 {\n    let dimensions = textureDimensions(debug_data_texture);\n    var index = *i;\n    let v = textureLoad(debug_data_texture, vec2<u32>(index % dimensions.x, index / dimensions.x), 0);\n    *i = index + 1u;\n    return v.r;\n}\n\nfn draw_triangle_from_visibility(visibility_id: u32, pixel: vec2<u32>, dimensions: vec2<u32>) -> vec3<f32>{\n    let meshlet_id = (visibility_id >> 8u) - 1u;\n    let primitive_id = visibility_id & 255u;\n    let meshlet = &meshlets.data[meshlet_id];\n    let index_offset = (*meshlet).indices_offset + (primitive_id * 3u);\n\n    let mesh_id = u32((*meshlet).mesh_index);\n    let mesh = &meshes.data[mesh_id];\n    let position_offset = (*mesh).vertices_position_offset;\n    \n    let vert_indices = vec3<u32>(indices.data[index_offset], indices.data[index_offset + 1u], indices.data[index_offset + 2u]);\n    \n    let p1 = runtime_vertices.data[vert_indices.x + position_offset].world_pos;\n    let p2 = runtime_vertices.data[vert_indices.y + position_offset].world_pos;\n    let p3 = runtime_vertices.data[vert_indices.z + position_offset].world_pos;\n    \n    let line_color = vec3<f32>(0., 1., 1.);\n    let line_size = 0.001;\n    var color = vec3<f32>(0.);\n    color += draw_line_3d(pixel, dimensions, p1, p2, line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, p2, p3, line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, p3, p1, line_color, line_size);\n    return color;\n}\n\nfn draw_cube_from_min_max(min: vec3<f32>, max:vec3<f32>, pixel: vec2<u32>, dimensions: vec2<u32>) -> vec3<f32> {  \n    let line_color = vec3<f32>(0., 0., 1.);\n    let line_size = 0.003;\n    var color = vec3<f32>(0.);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, min.y, min.z), vec3<f32>(max.x, min.y, min.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, min.y, min.z), vec3<f32>(max.x, min.y, max.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, min.y, max.z), vec3<f32>(min.x, min.y, max.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, min.y, max.z), vec3<f32>(min.x, min.y, min.z), line_color, line_size);\n    //\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, max.y, min.z), vec3<f32>(max.x, max.y, min.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, max.y, min.z), vec3<f32>(max.x, max.y, max.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, max.y, max.z), vec3<f32>(min.x, max.y, max.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, max.y, max.z), vec3<f32>(min.x, max.y, min.z), line_color, line_size);\n    //\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, min.y, min.z), vec3<f32>(min.x, max.y, min.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(min.x, min.y, max.z), vec3<f32>(min.x, max.y, max.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, min.y, min.z), vec3<f32>(max.x, max.y, min.z), line_color, line_size);\n    color += draw_line_3d(pixel, dimensions, vec3<f32>(max.x, min.y, max.z), vec3<f32>(max.x, max.y, max.z), line_color, line_size);\n    return color;\n}\n\nfn debug_color_override(color: vec4<f32>, pixel: vec2<u32>, dimensions: vec2<u32>) -> vec4<f32> {\n    var out_color = color;\n    if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS) != 0) {\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            let meshlet_id = (visibility_id >> 8u); \n            let meshlet_color = hash(meshlet_id + 1u);\n            out_color = vec4<f32>(vec3<f32>(\n                f32(meshlet_color & 255u),\n                f32((meshlet_color >> 8u) & 255u),\n                f32((meshlet_color >> 16u) & 255u)\n            ) / 255., 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_UV_0) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            out_color = vec4<f32>(vec3<f32>(pixel_data.uv_set[0], 0.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_UV_1) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            out_color = vec4<f32>(vec3<f32>(pixel_data.uv_set[1], 0.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_UV_2) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            out_color = vec4<f32>(vec3<f32>(pixel_data.uv_set[2], 0.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_UV_3) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            out_color = vec4<f32>(vec3<f32>(pixel_data.uv_set[3], 0.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_NORMALS) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            var material = materials.data[pixel_data.material_id];\n            let tbn = compute_tbn(&material, &pixel_data);\n            out_color = vec4<f32>((vec3<f32>(1.) + tbn.normal) / vec3<f32>(2.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_TANGENT) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            var material = materials.data[pixel_data.material_id];\n            let tbn = compute_tbn(&material, &pixel_data);\n            out_color = vec4<f32>((vec3<f32>(1.) + tbn.tangent) / vec3<f32>(2.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_BITANGENT) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            var material = materials.data[pixel_data.material_id];\n            let tbn = compute_tbn(&material, &pixel_data);\n            out_color = vec4<f32>((vec3<f32>(1.) + tbn.binormal) / vec3<f32>(2.), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_BASE_COLOR) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            let material_info = compute_color_from_material(pixel_data.material_id, &pixel_data);\n            out_color = vec4<f32>(vec3<f32>(material_info.base_color.rgb), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_METALLIC) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            let material_info = compute_color_from_material(pixel_data.material_id, &pixel_data);\n            out_color = vec4<f32>(vec3<f32>(material_info.metallic), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_ROUGHNESS) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let hit_point = pixel_to_world(depth_pixel, depth_dimensions, depth); \n\n        let visibility_dimensions = textureDimensions(visibility_texture);\n        let visibility_scale = vec2<f32>(visibility_dimensions) / vec2<f32>(dimensions);\n        let visibility_pixel = vec2<u32>(vec2<f32>(pixel) * visibility_scale);\n        let visibility_value = textureLoad(visibility_texture, visibility_pixel, 0);\n        let visibility_id = visibility_value.r;\n        if (visibility_id != 0u && (visibility_id & 0xFFFFFFFFu) != 0xFF000000u) {\n            var pixel_data = visibility_to_gbuffer(visibility_id, hit_point);\n            let material_info = compute_color_from_material(pixel_data.material_id, &pixel_data);\n            out_color = vec4<f32>(vec3<f32>(material_info.perceptual_roughness), 1.);\n        }\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_RADIANCE_BUFFER) != 0) {\n        let radiance_dimensions = textureDimensions(radiance_texture);\n        let radiance_scale = vec2<f32>(radiance_dimensions) / vec2<f32>(dimensions);\n        let radiance_pixel = vec2<u32>(vec2<f32>(pixel) * radiance_scale);\n        out_color = textureLoad(radiance_texture, radiance_pixel, 0);\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_DEPTH_BUFFER) != 0) {\n        let depth_dimensions = textureDimensions(depth_texture);\n        let depth_scale = vec2<f32>(depth_dimensions) / vec2<f32>(dimensions);\n        let depth_pixel = vec2<u32>(vec2<f32>(pixel) * depth_scale);\n        let depth = textureLoad(depth_texture, depth_pixel, 0);\n        let v = vec3<f32>(1. - depth) * 10.;\n        out_color = vec4<f32>(v, 1.);\n    } \n    else if ((constant_data.flags & CONSTANT_DATA_FLAGS_DISPLAY_PATHTRACE) != 0) {\n        let debug_dimensions = textureDimensions(debug_data_texture);\n        let debug_scale = vec2<f32>(debug_dimensions) / vec2<f32>(dimensions);\n        let debug_pixel = vec2<u32>(vec2<f32>(pixel) * debug_scale);\n        var origin = vec3<f32>(0.);\n        var direction = vec3<f32>(0.);\n        let line_color = vec3<f32>(0., 1., 0.);\n        let line_size = 0.003;\n        var bounce_index = 0u;\n        var color = out_color.rgb;        \n        /*\n        var debug_bhv_index = 100u;\n        let max_bhv_index = u32(read_value_from_debug_data_texture(&debug_bhv_index));\n        while(debug_bhv_index < max_bhv_index) \n        {\n            var min = vec3<f32>(0.);\n            min.x = read_value_from_debug_data_texture(&debug_bhv_index);\n            min.y = read_value_from_debug_data_texture(&debug_bhv_index);\n            min.z = read_value_from_debug_data_texture(&debug_bhv_index);\n            var max = vec3<f32>(0.);\n            max.x = read_value_from_debug_data_texture(&debug_bhv_index);\n            max.y = read_value_from_debug_data_texture(&debug_bhv_index);\n            max.z = read_value_from_debug_data_texture(&debug_bhv_index);\n            color += draw_cube_from_min_max(min, max, debug_pixel, debug_dimensions);\n            //color += draw_line_3d(debug_pixel, debug_dimensions, min, max, vec3<f32>(0.,0.,1.), line_size);\n        }\n        */\n        \n        var debug_index = 0u;\n        let max_index = u32(read_value_from_debug_data_texture(&debug_index));\n        while(debug_index < max_index) {\n            let visibility_id = u32(read_value_from_debug_data_texture(&debug_index));\n            color += draw_triangle_from_visibility(visibility_id, debug_pixel, debug_dimensions);\n            \n            var previous = origin;\n            origin.x = read_value_from_debug_data_texture(&debug_index);\n            origin.y = read_value_from_debug_data_texture(&debug_index);\n            origin.z = read_value_from_debug_data_texture(&debug_index);\n            direction.x = read_value_from_debug_data_texture(&debug_index);\n            direction.y = read_value_from_debug_data_texture(&debug_index);\n            direction.z = read_value_from_debug_data_texture(&debug_index);\n            if (bounce_index > 0u) {\n                color += draw_line_3d(debug_pixel, debug_dimensions, previous, origin, line_color, line_size);\n            }\n            bounce_index += 1u;\n        }\n        color += draw_line_3d(debug_pixel, debug_dimensions, origin, origin + direction * 5., line_color, line_size);\n        out_color = vec4<f32>(color, 1.);\n    } \n    return out_color;\n}\n\n\n\n@vertex\nfn vs_main(@builtin(vertex_index) in_vertex_index: u32) -> VertexOutput {\n    //only one triangle, exceeding the viewport size\n    let uv = vec2<f32>(f32((in_vertex_index << 1u) & 2u), f32(in_vertex_index & 2u));\n    let pos = vec4<f32>(uv * vec2<f32>(2., -2.) + vec2<f32>(-1., 1.), 0., 1.);\n\n    var vertex_out: VertexOutput;\n    vertex_out.clip_position = pos;\n    vertex_out.uv = uv;\n    return vertex_out;\n}\n\n@fragment\nfn fs_main(v_in: VertexOutput) -> @location(0) vec4<f32> {\n    let dimensions = textureDimensions(finalize_texture);\n    let pixel = vec2<u32>(u32(v_in.uv.x * f32(dimensions.x)), u32(v_in.uv.y * f32(dimensions.y)));\n\n    var out_color = textureLoad(finalize_texture, pixel, 0);    \n    out_color = debug_color_override(out_color, pixel, dimensions); \n    return out_color;\n}\n"
}