{"spirv_code":[],"wgsl_code":"let MAX_TEXTURE_ATLAS_COUNT: u32 = 16u;\nlet MAX_TEXTURE_COORDS_SET: u32 = 4u;\n\nlet TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\nlet TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\nlet TEXTURE_TYPE_NORMAL: u32 = 2u;\nlet TEXTURE_TYPE_EMISSIVE: u32 = 3u;\nlet TEXTURE_TYPE_OCCLUSION: u32 = 4u;\nlet TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\nlet TEXTURE_TYPE_DIFFUSE: u32 = 6u;\nlet TEXTURE_TYPE_EMPTY_FOR_PADDING: u32 = 7u;\nlet TEXTURE_TYPE_COUNT: u32 = 8u;\n\nlet MATERIAL_ALPHA_BLEND_OPAQUE = 0u;\nlet MATERIAL_ALPHA_BLEND_MASK = 1u;\nlet MATERIAL_ALPHA_BLEND_BLEND = 2u;\n\nlet MESH_FLAGS_NONE: u32 = 0u;\nlet MESH_FLAGS_VISIBLE: u32 = 1u;\nlet MESH_FLAGS_OPAQUE: u32 = 2u; // 1 << 1\nlet MESH_FLAGS_TRANSPARENT: u32 = 4u;  // 1 << 2\nlet MESH_FLAGS_WIREFRAME: u32 = 8u; // 1 << 3\nlet MESH_FLAGS_DEBUG: u32 = 16u; // 1 << 4\nlet MESH_FLAGS_UI: u32 = 32u; // 1 << 5\n\nlet CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\nlet CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS: u32 = 2u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_SPHERE: u32 = 4u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_BOUNDING_BOX: u32 = 8u;\n\n\nstruct ConstantData {\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    screen_width: f32,\n    screen_height: f32,\n    flags: u32,\n};\n\nstruct DrawVertex {\n    @location(0) position_and_color_offset: u32,\n    @location(1) normal_offset: i32,\n    @location(2) tangent_offset: i32,\n    @location(3) padding_offset: u32,\n    @location(4) uvs_offset: vec4<i32>,\n};\n\nstruct DrawInstance {\n    @location(5) mesh_index: u32,\n    @location(6) matrix_index: u32,\n};\nstruct DrawCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_index: u32,\n    vertex_offset: i32,\n    base_instance: u32,\n};\n\nstruct DrawMesh {\n    vertex_offset: u32,\n    indices_offset: u32,\n    meshlet_offset: u32,\n    meshlet_count: u32,\n    instance_index: i32,\n    material_index: i32,\n    matrix_index: i32,\n    mesh_flags: u32,\n};\n\nstruct DrawMeshlet {\n    mesh_index: u32,\n    vertex_offset: u32,\n    indices_offset: u32,\n    indices_count: u32,\n    center_radius: vec4<f32>,\n    cone_axis_cutoff: vec4<f32>,\n};\n\n\nstruct LightData {\n    position: vec3<f32>,\n    light_type: u32,\n    color: vec4<f32>,\n    intensity: f32,\n    range: f32,\n    inner_cone_angle: f32,\n    outer_cone_angle: f32,\n};\n\nstruct TextureData {\n    texture_index: u32,\n    layer_index: u32,\n    total_width: f32,\n    total_height: f32,\n    area: vec4<f32>,\n};\n\nstruct DrawMaterial {\n    textures_indices: array<i32, 8>,//TEXTURE_TYPE_COUNT>,\n    textures_coord_set: array<u32, 8>,//TEXTURE_TYPE_COUNT>,\n    roughness_factor: f32,\n    metallic_factor: f32,\n    alpha_cutoff: f32,\n    alpha_mode: u32,\n    base_color: vec4<f32>,\n    emissive_color: vec3<f32>,\n    occlusion_strength: f32,\n    diffuse_color: vec4<f32>,\n    specular_color: vec4<f32>,\n};\n\n\nstruct Lights {\n    data: array<LightData>,\n};\n\nstruct Textures {\n    data: array<TextureData>,\n};\n\nstruct Materials {\n    data: array<DrawMaterial>,\n};\n\nstruct Instances {\n    data: array<DrawInstance>,\n};\n\nstruct Commands {\n    data: array<DrawCommand>,\n};\n\nstruct Meshes {\n    data: array<DrawMesh>,\n};\n\nstruct Meshlets {\n    data: array<DrawMeshlet>,\n};\n\nstruct Indices {\n    data: array<u32>,\n};\n\nstruct Vertices {\n    data: array<DrawVertex>,\n};\n\nstruct Matrices {\n    data: array<mat4x4<f32>>,\n};\n\nstruct PositionsAndColors {\n    data: array<vec4<f32>>,\n};\n\nstruct NormalsAndPadding {\n    data: array<vec4<f32>>,\n};\n\nstruct Tangents {\n    data: array<vec4<f32>>,\n};\n\nstruct UVs {\n    data: array<vec2<f32>>,\n};\n\n\nstruct VertexOutput {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) id: u32,\n};\n\nstruct FragmentOutput {\n    @location(0) output: vec4<f32>,\n};\n\n@group(0) @binding(0)\nvar<uniform> constant_data: ConstantData;\n@group(0) @binding(1)\nvar<storage, read> positions_and_colors: PositionsAndColors;\n@group(0) @binding(2)\nvar<storage, read> meshes: Meshes;\n@group(0) @binding(3)\nvar<storage, read> meshlets: Meshlets;\n@group(0) @binding(4)\nvar<storage, read> matrices: Matrices;\n\n@vertex\nfn vs_main(\n    @builtin(instance_index) instance_index: u32,\n    v_in: DrawVertex,\n    i_in: DrawInstance,\n) -> VertexOutput {\n    \n    let meshlet_id = extractBits(instance_index, 0u, 24u);\n    let meshlet = &meshlets.data[meshlet_id];\n    let mesh_id = (*meshlet).mesh_index;\n    let mesh = &meshes.data[mesh_id];\n    let matrix_id = (*mesh).matrix_index;\n\n    let instance_matrix = &matrices.data[matrix_id];\n    let p = &positions_and_colors.data[v_in.position_and_color_offset];\n    let world_position = (*instance_matrix) * vec4<f32>((*p).xyz, 1.0);\n    let mvp = constant_data.proj * constant_data.view;\n\n    var vertex_out: VertexOutput;\n    vertex_out.clip_position = mvp * world_position;\n    vertex_out.id = instance_index;    \n    return vertex_out;\n}\n\n@fragment\nfn fs_main(\n    v_in: VertexOutput,\n) -> FragmentOutput {    \n    var fragment_out: FragmentOutput;\n    fragment_out.output = unpack4x8unorm(v_in.id);    \n    return fragment_out;\n}\n"}