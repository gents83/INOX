{"spirv_code":[],"wgsl_code":"\nfn pack_normal(normal: vec3<f32>) -> vec2<f32> {\n    return vec2<f32>(normal.xy * 0.5 + 0.5);\n}\nfn unpack_normal(uv: vec2<f32>) -> vec3<f32> {\n    return vec3<f32>(uv.xy * 2. - 1., sqrt(1.-dot(uv.xy, uv.xy)));\n}\n\nfn unpack_unorm_to_4_f32(color: u32) -> vec4<f32> {\n    return vec4<f32>(\n        f32(((color >> 24u) / 255u) & 255u),\n        f32(((color >> 16u) / 255u) & 255u),\n        f32(((color >> 8u) / 255u) & 255u),\n        f32((color / 255u) & 255u),\n    );\n}\n\nfn hash(index: u32) -> u32 {\n    var v = index;\n    v = (v + 0x7ed55d16u) + (v << 12u);\n    v = (v ^ 0xc761c23cu) ^ (v >> 19u);\n    v = (v + 0x165667b1u) + (v << 5u);\n    v = (v + 0xd3a2646cu) ^ (v << 9u);\n    v = (v + 0xfd7046c5u) + (v << 3u);\n    v = (v ^ 0xb55a4f09u) ^ (v >> 16u);\n    return v;\n}\n\n// 0-1 from 0-255\nfn linear_from_srgb(srgb: vec3<f32>) -> vec3<f32> {\n    let cutoff = srgb < vec3<f32>(10.31475);\n    let lower = srgb / vec3<f32>(3294.6);\n    let higher = pow((srgb + vec3<f32>(14.025)) / vec3<f32>(269.025), vec3<f32>(2.4));\n    return select(higher, lower, cutoff);\n}\n\n// [u8; 4] SRGB as u32 -> [r, g, b, a]\nfn unpack_color(color: u32) -> vec4<f32> {\n    return vec4<f32>(\n        f32(color & 255u),\n        f32((color >> 8u) & 255u),\n        f32((color >> 16u) & 255u),\n        f32((color >> 24u) & 255u),\n    );\n}\n\nfn extract_scale(m: mat4x4<f32>) -> vec3<f32> {\n    let s = mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);\n    let sx = length(s[0]);\n    let sy = length(s[1]);\n    let det = determinant(s);\n    var sz = length(s[2]);\n    if (det < 0.) {\n        sz = -sz;\n    }\n    return vec3<f32>(sx, sy, sz);\n}\n\nfn matrix_row(m: mat4x4<f32>, row: u32) -> vec4<f32> {\n    if (row == 1u) {\n        return vec4<f32>(m[0].y, m[1].y, m[2].y, m[3].y);\n    } else if (row == 2u) {\n        return vec4<f32>(m[0].z, m[1].z, m[2].z, m[3].z);\n    } else if (row == 3u) {\n        return vec4<f32>(m[0].w, m[1].w, m[2].w, m[3].w);\n    } else {        \n        return vec4<f32>(m[0].x, m[1].x, m[2].x, m[3].x);\n    }\n}\n\nfn normalize_plane(plane: vec4<f32>) -> vec4<f32> {\n    return (plane / length(plane.xyz));\n}\nlet MAX_TEXTURE_ATLAS_COUNT: u32 = 16u;\nlet MAX_TEXTURE_COORDS_SET: u32 = 4u;\n\nlet TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\nlet TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\nlet TEXTURE_TYPE_NORMAL: u32 = 2u;\nlet TEXTURE_TYPE_EMISSIVE: u32 = 3u;\nlet TEXTURE_TYPE_OCCLUSION: u32 = 4u;\nlet TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\nlet TEXTURE_TYPE_DIFFUSE: u32 = 6u;\nlet TEXTURE_TYPE_EMPTY_FOR_PADDING: u32 = 7u;\nlet TEXTURE_TYPE_COUNT: u32 = 8u;\n\nlet MATERIAL_ALPHA_BLEND_OPAQUE = 0u;\nlet MATERIAL_ALPHA_BLEND_MASK = 1u;\nlet MATERIAL_ALPHA_BLEND_BLEND = 2u;\n\nlet MESH_FLAGS_NONE: u32 = 0u;\nlet MESH_FLAGS_VISIBLE: u32 = 1u;\nlet MESH_FLAGS_OPAQUE: u32 = 2u; // 1 << 1\nlet MESH_FLAGS_TRANSPARENT: u32 = 4u;  // 1 << 2\nlet MESH_FLAGS_WIREFRAME: u32 = 8u; // 1 << 3\nlet MESH_FLAGS_DEBUG: u32 = 16u; // 1 << 4\nlet MESH_FLAGS_UI: u32 = 32u; // 1 << 5\n\nlet CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\nlet CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS: u32 = 2u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_SPHERE: u32 = 4u;\nlet CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_BOUNDING_BOX: u32 = 8u;\n\n\nstruct ConstantData {\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    inverse_view_proj: mat4x4<f32>,\n    screen_width: f32,\n    screen_height: f32,\n    flags: u32,\n};\n\nstruct DrawVertex {\n    @location(0) position_and_color_offset: u32,\n    @location(1) normal_offset: i32,\n    @location(2) tangent_offset: i32,\n    @location(3) mesh_index: u32,\n    @location(4) uvs_offset: vec4<i32>,\n};\n\nstruct DrawCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_vertex: u32,\n    base_instance: u32,\n};\n\nstruct DrawIndexedCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_index: u32,\n    vertex_offset: i32,\n    base_instance: u32,\n};\n\nstruct DrawMesh {\n    vertex_offset: u32,\n    indices_offset: u32,\n    meshlet_offset: u32,\n    meshlet_count: u32,\n    material_index: i32,\n    mesh_flags: u32,\n    _padding1: u32,\n    _padding2: u32,\n    transform: mat4x4<f32>,\n};\n\nstruct DrawMeshlet {\n    @location(5) mesh_index: u32,\n    @location(6) vertex_offset: u32,\n    @location(7) indices_offset: u32,\n    @location(8) indices_count: u32,\n    @location(9) center_radius: vec4<f32>,\n    @location(10) cone_axis_cutoff: vec4<f32>,\n};\n\n\nstruct LightData {\n    position: vec3<f32>,\n    light_type: u32,\n    color: vec4<f32>,\n    intensity: f32,\n    range: f32,\n    inner_cone_angle: f32,\n    outer_cone_angle: f32,\n};\n\nstruct TextureData {\n    texture_index: u32,\n    layer_index: u32,\n    total_width: f32,\n    total_height: f32,\n    area: vec4<f32>,\n};\n\nstruct DrawMaterial {\n    textures_indices: array<i32, 8>,//TEXTURE_TYPE_COUNT>,\n    textures_coord_set: array<u32, 8>,//TEXTURE_TYPE_COUNT>,\n    roughness_factor: f32,\n    metallic_factor: f32,\n    alpha_cutoff: f32,\n    alpha_mode: u32,\n    base_color: vec4<f32>,\n    emissive_color: vec3<f32>,\n    occlusion_strength: f32,\n    diffuse_color: vec4<f32>,\n    specular_color: vec4<f32>,\n};\n\n\nstruct Lights {\n    data: array<LightData>,\n};\n\nstruct Textures {\n    data: array<TextureData>,\n};\n\nstruct Materials {\n    data: array<DrawMaterial>,\n};\n\nstruct DrawCommands {\n    data: array<DrawCommand>,\n};\n\nstruct DrawIndexedCommands {\n    data: array<DrawIndexedCommand>,\n};\n\nstruct Meshes {\n    data: array<DrawMesh>,\n};\n\nstruct Meshlets {\n    data: array<DrawMeshlet>,\n};\n\nstruct Indices {\n    data: array<u32>,\n};\n\nstruct Vertices {\n    data: array<DrawVertex>,\n};\n\nstruct Matrices {\n    data: array<mat4x4<f32>>,\n};\n\nstruct PositionsAndColors {\n    data: array<vec4<f32>>,\n};\n\nstruct NormalsAndPadding {\n    data: array<vec4<f32>>,\n};\n\nstruct Tangents {\n    data: array<vec4<f32>>,\n};\n\nstruct UVs {\n    data: array<vec2<f32>>,\n};\n\n\n@group(0) @binding(0)\nvar<uniform> constant_data: ConstantData;\n@group(0) @binding(1)\nvar<storage, read> indices: Indices;\n@group(0) @binding(2)\nvar<storage, read> vertices: Vertices;\n@group(0) @binding(3)\nvar<storage, read> positions: PositionsAndColors;\n@group(0) @binding(4)\nvar<storage, read> meshes: Meshes;\n@group(0) @binding(5)\nvar<storage, read> meshlets: Meshlets;\n\n@group(1) @binding(0)\nvar render_target: texture_storage_2d_array<r32sint, read_write>;\n\n\nfn project(v: vec3<f32>, mvp: mat4x4<f32>, m: mat4x4<f32>) -> vec2<f32> {\n    let world_position = m * vec4<f32>(v, 1.0);\n    var clip_position = mvp * world_position;\n    clip_position.x = ((1. + (clip_position.x / clip_position.w)) / 2.) * constant_data.screen_width;\n    clip_position.y = (1. - (1. + (clip_position.y / clip_position.w)) / 2.) * constant_data.screen_height;\n    return clip_position.xy;\n}\n\nfn is_off_screen(x: i32, y: i32) -> bool {\n    if (x < 0 || x > i32(constant_data.screen_width) || y < 0 ||\n        y > i32(constant_data.screen_height)) {\n        return true;\n    }\n    return false;\n}\n\nfn is_point_off_screen(p: vec2<f32>) -> bool {\n    return is_off_screen(i32(p.x), i32(p.y));\n}\n\nfn compute_min_max(v1: vec2<f32>, v2: vec2<f32>, v3: vec2<f32>) -> vec4<f32> {\n    var min_max = vec4<f32>(0.);\n    min_max.x = min(min(v1.x, v2.x), v3.x);\n    min_max.y = min(min(v1.y, v2.y), v3.y);\n    min_max.z = max(max(v1.x, v2.x), v3.x);\n    min_max.w = max(max(v1.y, v2.y), v3.y); \n    return min_max;\n}\n\n// From: https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling\nfn barycentric(v1: vec2<f32>, v2: vec2<f32>, v3: vec2<f32>, p: vec2<f32>) -> vec3<f32> {\n    let u = cross(\n        vec3<f32>(v3.x - v1.x, v2.x - v1.x, v1.x - p.x), \n        vec3<f32>(v3.y - v1.y, v2.y - v1.y, v1.y - p.y)\n    );\n    if (abs(u.z) < 1.0) {\n        return vec3<f32>(-1.0, 1.0, 1.0);\n    }\n    return vec3<f32>(1.0 - (u.x+u.y)/u.z, u.y/u.z, u.x/u.z); \n}\n\nfn write_pixel(x: i32, y: i32, v: u32) {\n    textureStore(render_target, vec2<i32>(x, y), 0, vec4<i32>(i32(v), i32(v), i32(v), i32(v)));\n}\n\nfn draw_triangle(v1: vec2<f32>, v2: vec2<f32>, v3: vec2<f32>, index: u32) {\n    let min_max = compute_min_max(v1, v2, v3);\n    let start_x = i32(min_max.x);\n    let start_y = i32(min_max.y);\n    let end_x = i32(min_max.z);\n    let end_y = i32(min_max.w); \n    for (var x: i32 = start_x; x <= end_x; x = x + 1) {\n        for (var y : i32 = start_y; y <= end_y; y = y + 1) {\n            let bc = barycentric(v1, v2, v3, vec2<f32>(f32(x), f32(y)));\n            if (bc.x < 0.0 || bc.y < 0.0 || bc.z < 0.0) {\n                continue;\n            }\n            write_pixel(x, y, index);\n        }\n    }\n}\n\nfn draw_line(v1: vec3<f32>, v2: vec3<f32>, index: u32) {\n    let a = vec2<f32>(v1.x, v1.y);\n    let b = vec2<f32>(v2.x, v2.y);\n\n    let dist = i32(distance(a, b));\n    for (var i = 0; i < dist; i = i + 1) {\n        let x = i32(v1.x + f32(v2.x - v1.x) * (f32(i) / f32(dist)));\n        let y = i32(v1.y + f32(v2.y - v1.y) * (f32(i) / f32(dist)));\n        write_pixel(x, y, index);\n    }\n}\n\nfn draw_point(v: vec2<f32>, index: u32) {\n    write_pixel(i32(v.x), i32(v.y), index);\n}\n\n@compute\n@workgroup_size(16, 1, 1)\nfn main(\n    @builtin(local_invocation_id) local_invocation_id: vec3<u32>, \n    @builtin(local_invocation_index) local_invocation_index: u32, \n    @builtin(global_invocation_id) global_invocation_id: vec3<u32>, \n    @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n    let meshlet_id = global_invocation_id.x;\n    let num_meshlets = arrayLength(&meshlets.data);\n    if (meshlet_id >= num_meshlets) {\n        return;\n    }\n\n    let num_meshes = arrayLength(&meshes.data);\n    var mesh_id = 0u;\n    for(var mi = 0u; mi < num_meshes; mi++) {\n        if meshlet_id >= meshes.data[mi].meshlet_offset &&\n            meshlet_id < meshes.data[mi].meshlet_offset + meshes.data[mi].meshlet_count {\n                mesh_id = mi;\n                break;\n        }\n    }\n\n    let meshlet = &meshlets.data[meshlet_id];\n    let mesh = &meshes.data[mesh_id];  \n    let mvp = constant_data.proj * constant_data.view;\n    let start = u32((*mesh).indices_offset + (*meshlet).indices_offset);\n    let end = u32(((*mesh).indices_offset + (*meshlet).indices_offset + (*meshlet).indices_count));  \n    let offset = (*mesh).vertex_offset + (*meshlet).vertex_offset;\n    for(var i = start; i < end; i = i + 3u) {\n        let index = offset + i;\n        let i1 = indices.data[index + 0u];\n        let i2 = indices.data[index + 1u];\n        let i3 = indices.data[index + 2u];\n\n        let v1 = &vertices.data[i1];\n        let v2 = &vertices.data[i2];\n        let v3 = &vertices.data[i3];\n        \n        let p1 = project(positions.data[(*v1).position_and_color_offset].xyz, mvp, (*mesh).transform);\n        let p2 = project(positions.data[(*v2).position_and_color_offset].xyz, mvp, (*mesh).transform);\n        let p3 = project(positions.data[(*v3).position_and_color_offset].xyz, mvp, (*mesh).transform);\n        \n        if (is_point_off_screen(p1) || is_point_off_screen(p2) || is_point_off_screen(p3)) {\n            continue;\n        }        \n        draw_triangle(p1, p2, p3, meshlet_id);\n    }   \n}\n"}