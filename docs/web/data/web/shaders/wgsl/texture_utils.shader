{"spirv_code":[],"wgsl_code":"@group(2) @binding(0)\nvar default_sampler: sampler;\n\n@group(2) @binding(1)\nvar texture_1: texture_2d_array<f32>;\n@group(2) @binding(2)\nvar texture_2: texture_2d_array<f32>;\n@group(2) @binding(3)\nvar texture_3: texture_2d_array<f32>;\n@group(2) @binding(4)\nvar texture_4: texture_2d_array<f32>;\n@group(2) @binding(5)\nvar texture_5: texture_2d_array<f32>;\n@group(2) @binding(6)\nvar texture_6: texture_2d_array<f32>;\n@group(2) @binding(7)\nvar texture_7: texture_2d_array<f32>;\n@group(2) @binding(8)\nvar texture_8: texture_2d_array<f32>;\n@group(2) @binding(9)\nvar texture_9: texture_2d_array<f32>;\n@group(2) @binding(10)\nvar texture_10: texture_2d_array<f32>;\n@group(2) @binding(11)\nvar texture_11: texture_2d_array<f32>;\n@group(2) @binding(12)\nvar texture_12: texture_2d_array<f32>;\n@group(2) @binding(13)\nvar texture_13: texture_2d_array<f32>;\n@group(2) @binding(14)\nvar texture_14: texture_2d_array<f32>;\n@group(2) @binding(15)\nvar texture_15: texture_2d_array<f32>;\n\n\nfn sample_texture(tex_coords_and_texture_index: vec3<f32>) -> vec4<f32> {\n    let texture_data_index = i32(tex_coords_and_texture_index.z);\n    var v = vec4<f32>(0.);\n    var tex_coords = vec3<f32>(0.0, 0.0, 0.0);\n    if (texture_data_index < 0) {\n        return v;\n    }\n    let texture = &textures.data[texture_data_index];\n    let atlas_index = (*texture).texture_index;\n    let layer_index = i32((*texture).layer_index);\n\n    tex_coords.x = ((*texture).area.x + tex_coords_and_texture_index.x * (*texture).area.z) / (*texture).total_width;\n    tex_coords.y = ((*texture).area.y + tex_coords_and_texture_index.y * (*texture).area.w) / (*texture).total_height;\n    tex_coords.z = f32(layer_index);\n\n    switch (atlas_index) {\n        case 0u: { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 1u: { v = textureSampleLevel(texture_2, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 2u: { v = textureSampleLevel(texture_3, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 3u: { v = textureSampleLevel(texture_4, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 4u: { v = textureSampleLevel(texture_5, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 5u: { v = textureSampleLevel(texture_6, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 6u: { v = textureSampleLevel(texture_7, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 7u: { v = textureSampleLevel(texture_8, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 9u: { v = textureSampleLevel(texture_9, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 10u: { v = textureSampleLevel(texture_10, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 11u: { v = textureSampleLevel(texture_11, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 12u: { v = textureSampleLevel(texture_12, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 13u: { v = textureSampleLevel(texture_13, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 14u: { v = textureSampleLevel(texture_14, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 15u: { v = textureSampleLevel(texture_15, default_sampler, tex_coords.xy, layer_index, 0.); }\n        default { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n    };\n    return v;\n}\n\n\n\nfn load_texture(tex_coords_and_texture_index: vec3<i32>) -> vec4<f32> {\n    let atlas_index = tex_coords_and_texture_index.z;\n    let layer_index = 0;\n    var v = vec4<f32>(0.);\n\n    switch (atlas_index) {\n        case 0: { v = textureLoad(texture_1, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 1: { v = textureLoad(texture_2, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 2: { v = textureLoad(texture_3, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 3: { v = textureLoad(texture_4, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 4: { v = textureLoad(texture_5, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 5: { v = textureLoad(texture_6, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 6: { v = textureLoad(texture_7, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 7: { v = textureLoad(texture_8, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 8: { v = textureLoad(texture_9, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 9: { v = textureLoad(texture_10, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 10: { v = textureLoad(texture_11, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 11: { v = textureLoad(texture_12, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 12: { v = textureLoad(texture_13, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 13: { v = textureLoad(texture_14, tex_coords_and_texture_index.xy, layer_index, 0); }\n        case 14: { v = textureLoad(texture_15, tex_coords_and_texture_index.xy, layer_index, 0); }\n        default { v = textureLoad(texture_1, tex_coords_and_texture_index.xy, layer_index, 0); }\n    }\n    return v;\n}\n\nfn get_uv(uv_set: vec4<u32>, texture_index: u32, coords_set: u32) -> vec3<f32> {\n    var uv = vec2<f32>(0., 0.);\n    switch (coords_set) {\n        case 1u: { uv = unpack2x16float(uv_set.y); }\n        case 2u: { uv = unpack2x16float(uv_set.z); }\n        case 3u: { uv = unpack2x16float(uv_set.w); }\n        default { uv = unpack2x16float(uv_set.x); }\n    }\n    return vec3<f32>(uv, f32(texture_index));\n}\n\n"}