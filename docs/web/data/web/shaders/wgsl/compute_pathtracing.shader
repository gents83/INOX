{"spirv_code":[],"wgsl_code":"const MAX_TEXTURE_ATLAS_COUNT: u32 = 8u;\nconst MAX_TEXTURE_COORDS_SET: u32 = 4u;\n\nconst TEXTURE_TYPE_BASE_COLOR: u32 = 0u;\nconst TEXTURE_TYPE_METALLIC_ROUGHNESS: u32 = 1u;\nconst TEXTURE_TYPE_NORMAL: u32 = 2u;\nconst TEXTURE_TYPE_EMISSIVE: u32 = 3u;\nconst TEXTURE_TYPE_OCCLUSION: u32 = 4u;\nconst TEXTURE_TYPE_SPECULAR_GLOSSINESS: u32 = 5u;\nconst TEXTURE_TYPE_DIFFUSE: u32 = 6u;\nconst TEXTURE_TYPE_EMPTY_FOR_PADDING: u32 = 7u;\nconst TEXTURE_TYPE_COUNT: u32 = 8u;\n\nconst MATERIAL_ALPHA_BLEND_OPAQUE = 0u;\nconst MATERIAL_ALPHA_BLEND_MASK = 1u;\nconst MATERIAL_ALPHA_BLEND_BLEND = 2u;\n\nconst MESH_FLAGS_NONE: u32 = 0u;\nconst MESH_FLAGS_VISIBLE: u32 = 1u;\nconst MESH_FLAGS_OPAQUE: u32 = 2u; // 1 << 1\nconst MESH_FLAGS_TRANSPARENT: u32 = 4u;  // 1 << 2\nconst MESH_FLAGS_WIREFRAME: u32 = 8u; // 1 << 3\nconst MESH_FLAGS_DEBUG: u32 = 16u; // 1 << 4\nconst MESH_FLAGS_UI: u32 = 32u; // 1 << 5\n\nconst CONSTANT_DATA_FLAGS_NONE: u32 = 0u;\nconst CONSTANT_DATA_FLAGS_SUPPORT_SRGB: u32 = 1u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS: u32 = 2u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_SPHERE: u32 = 4u;\nconst CONSTANT_DATA_FLAGS_DISPLAY_MESHLETS_BOUNDING_BOX: u32 = 8u;\n\nconst PI: f32 = 3.141592653589793238462643;\nconst MAX_FLOAT: f32 = 3.402823466e+38;\n\nconst VERTEX_ATTRIBUTE_HAS_POSITION: u32 = 0u;\nconst VERTEX_ATTRIBUTE_HAS_COLOR: u32 = 1u;\nconst VERTEX_ATTRIBUTE_HAS_NORMAL: u32 = 2u; // 1 << 1\nconst VERTEX_ATTRIBUTE_HAS_UV1: u32 = 4u; // 1 << 2\nconst VERTEX_ATTRIBUTE_HAS_UV2: u32 = 8u;  // 1 << 3\nconst VERTEX_ATTRIBUTE_HAS_UV3: u32 = 16u; // 1 << 4\nconst VERTEX_ATTRIBUTE_HAS_UV4: u32 = 32u; // 1 << 5\n\nstruct ConstantData {\n    view: mat4x4<f32>,\n    proj: mat4x4<f32>,\n    inverse_view_proj: mat4x4<f32>,\n    screen_width: f32,\n    screen_height: f32,\n    frame_index: u32,\n    flags: u32,\n};\n\nstruct RuntimeVertexData {\n    @location(0) world_pos: vec3<f32>,\n    @location(1) @interpolate(flat) mesh_index: u32,\n};\n\nstruct DrawCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_vertex: u32,\n    base_instance: u32,\n};\n\nstruct DrawIndexedCommand {\n    vertex_count: u32,\n    instance_count: u32,\n    base_index: u32,\n    vertex_offset: i32,\n    base_instance: u32,\n};\n\nstruct Mesh {\n    vertices_position_offset: u32,\n    vertices_attribute_offset: u32,\n    vertices_attribute_layout: u32,\n    material_index: i32,\n    orientation: vec4<f32>,\n    position: vec3<f32>,\n    meshlets_offset: u32,\n    scale: vec3<f32>,\n    blas_index: u32,\n};\n\nstruct ConeCulling {\n    center: vec3<f32>,\n    cone_axis_cutoff: u32,\n};\n\nstruct Meshlet {\n    @location(5) mesh_index: u32,\n    @location(6) indices_offset: u32,\n    @location(7) indices_count: u32,\n    @location(8) blas_index: u32,\n};\n\nstruct BHVNode {\n    min: vec3<f32>,\n    miss: i32,\n    max: vec3<f32>,\n    reference: i32, //-1 or mesh_index or meshlet_index or triangle_index\n};\n\n\nstruct LightData {\n    position: vec3<f32>,\n    light_type: u32,\n    color: vec4<f32>,\n    intensity: f32,\n    range: f32,\n    inner_cone_angle: f32,\n    outer_cone_angle: f32,\n};\n\nstruct TextureData {\n    texture_index: u32,\n    layer_index: u32,\n    total_width: f32,\n    total_height: f32,\n    area: vec4<f32>,\n};\n\nstruct Material {\n    textures_indices: array<i32, 8>,//TEXTURE_TYPE_COUNT>,\n    textures_coord_set: array<u32, 8>,//TEXTURE_TYPE_COUNT>,\n    roughness_factor: f32,\n    metallic_factor: f32,\n    alpha_cutoff: f32,\n    alpha_mode: u32,\n    base_color: vec4<f32>,\n    emissive_color: vec3<f32>,\n    occlusion_strength: f32,\n    diffuse_color: vec4<f32>,\n    specular_color: vec4<f32>,\n};\n\n\nstruct Lights {\n    data: array<LightData>,\n};\n\nstruct Textures {\n    data: array<TextureData>,\n};\n\nstruct Materials {\n    data: array<Material>,\n};\n\nstruct DrawCommands {\n    data: array<DrawCommand>,\n};\n\nstruct DrawIndexedCommands {\n    data: array<DrawIndexedCommand>,\n};\n\nstruct Meshes {\n    data: array<Mesh>,\n};\n\nstruct Meshlets {\n    data: array<Meshlet>,\n};\n\nstruct Indices {\n    data: array<u32>,\n};\n\nstruct RuntimeVertices {\n    data: array<RuntimeVertexData>,\n};\n\nstruct VerticesPositions {\n    data: array<u32>,\n};\n\nstruct VerticesAttributes {\n    data: array<u32>,\n};\n\nstruct MeshletsCulling {\n    data: array<ConeCulling>,\n};\n\nstruct Matrices {\n    data: array<mat4x4<f32>>,\n};\n\nstruct BHV {\n    data: array<BHVNode>,\n};\n\nstruct MeshFlags {\n    data: array<u32>,\n};\n\n\nstruct Ray {\n    origin: vec3<f32>,\n    t_min: f32,\n    direction: vec3<f32>,\n    t_max: f32,\n};\n\nstruct Rays {\n    data: array<Ray>,\n};\n\nstruct RayJob {\n    index: u32,\n    step: u32,\n}\n\nstruct PixelData {\n    world_pos: vec3<f32>,\n    depth: f32,\n    normal: vec3<f32>,\n    material_id: u32,\n    color: vec4<f32>,\n    uv_set: array<vec2<f32>, 4>,\n};\nfn quantize_unorm(v: f32, n: u32) -> u32 {\n    let scale = f32((1 << n) - 1);\n    return u32(0.5 + (v * scale));\n}\nfn quantize_snorm(v: f32, n: u32) -> u32 {\n    let c = (1u << (n - 1u)) - 1u;\n    let scale = f32(c);\n    if v < 0. {\n        return (u32(-v * scale) & c) | (1u << (n - 1u));\n    } else {\n        return u32(v * scale) & c;\n    }\n}\n\nfn decode_unorm(i: u32, n: u32) -> f32 {    \n    let scale = f32((1 << n) - 1);\n    if (i == 0u) {\n        return 0.;\n    } else if (i == u32(scale)) {\n        return 1.;\n    } else {\n        return (f32(i) - 0.5) / scale;\n    }\n}\n\nfn decode_snorm(i: u32, n: u32) -> f32 {\n    let s = i >> (n - 1u);\n    let c = (1u << (n - 1u)) - 1u;\n    let scale = f32(c);\n    if s > 0u {\n        let r = f32(i & c) / scale;\n        return -r;\n    } else {\n        return f32(i & c) / scale;\n    }\n}\n\nfn unpack_unorm_to_3_f32(v: u32) -> vec3<f32> {\n    let vx = decode_unorm((v >> 20u) & 0x000003FFu, 10u);\n    let vy = decode_unorm((v >> 10u) & 0x000003FFu, 10u);\n    let vz = decode_unorm(v & 0x000003FFu, 10u);\n    return vec3<f32>(vx, vy, vz);\n}\n\nfn unpack_snorm_to_3_f32(v: u32) -> vec3<f32> {\n    let vx = decode_snorm((v >> 20u) & 0x000003FFu, 10u);\n    let vy = decode_snorm((v >> 10u) & 0x000003FFu, 10u);\n    let vz = decode_snorm(v & 0x000003FFu, 10u);\n    return vec3<f32>(vx, vy, vz);\n}\n\nfn pack_normal(normal: vec3<f32>) -> vec2<f32> {\n    return vec2<f32>(normal.xy * 0.5 + 0.5);\n}\nfn unpack_normal(uv: vec2<f32>) -> vec3<f32> {\n    return vec3<f32>(uv.xy * 2. - 1., sqrt(1.-dot(uv.xy, uv.xy)));\n}\n\nfn pack_4_f32_to_unorm(value: vec4<f32>) -> u32 {\n    let r = quantize_unorm(value.x, 8u) << 24u;\n    let g = quantize_unorm(value.y, 8u) << 16u;\n    let b = quantize_unorm(value.z, 8u) << 8u;\n    let a = quantize_unorm(value.w, 8u);\n    return (r | g | b | a);\n}\nfn unpack_snorm_to_4_f32(v: u32) -> vec4<f32> {\n    let r = decode_snorm((v >> 24u) & 255u, 8u);\n    let g = decode_snorm((v >> 16u) & 255u, 8u);\n    let b = decode_snorm((v >> 8u) & 255u, 8u);\n    let a = decode_snorm(v & 255u, 8u);\n    return vec4<f32>(r,g,b,a);\n}\nfn unpack_unorm_to_4_f32(v: u32) -> vec4<f32> {\n    let r = decode_unorm((v >> 24u) & 255u, 8u);\n    let g = decode_unorm((v >> 16u) & 255u, 8u);\n    let b = decode_unorm((v >> 8u) & 255u, 8u);\n    let a = decode_unorm(v & 255u, 8u);\n    return vec4<f32>(r,g,b,a);\n}\n\nfn iq_hash(v: vec2<f32>) -> f32 {\n    return fract(sin(dot(v, vec2(11.9898, 78.233))) * 43758.5453);\n}\nfn blue_noise(in: vec2<f32>) -> f32 {\n    var v =  iq_hash( in + vec2<f32>(-1., 0.) )\n             + iq_hash( in + vec2<f32>( 1., 0.) )\n             + iq_hash( in + vec2<f32>( 0., 1.) )\n             + iq_hash( in + vec2<f32>( 0.,-1.) ); \n    v /= 4.;\n    return (iq_hash(in) - v + .5);\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nfn hash( x: u32 ) -> u32 {\n    var v = x;\n    v += ( v << 10u );\n    v ^= ( v >>  6u );\n    v += ( v <<  3u );\n    v ^= ( v >> 11u );\n    v += ( v << 15u );\n    return v;\n}\n\n// This is PCG\nfn get_random_numbers(seed: vec2<u32>) -> vec2<u32> {\n    var new_seed = seed;\n    new_seed = 1664525u * new_seed + 1013904223u;\n    new_seed.x += 1664525u * new_seed.y;\n    new_seed.y += 1664525u * new_seed.x;\n    new_seed.x = new_seed.x ^ (new_seed.x >> 16u);\n    new_seed.y = new_seed.y ^ (new_seed.y >> 16u);\n    new_seed.x += 1664525u * new_seed.y;\n    new_seed.y += 1664525u * new_seed.x;\n    new_seed.x = new_seed.x ^ (new_seed.x >> 16u);\n    new_seed.y = new_seed.y ^ (new_seed.y >> 16u);\n    return new_seed;\n}\n\nfn swap_f32(ptr_a: ptr<function, f32>, ptr_b: ptr<function, f32>) \n{\n    let c = *ptr_a;\n    *ptr_a = *ptr_b;\n    *ptr_b = c;\n}\n\nfn has_vertex_attribute(vertex_attribute_layout: u32, attribute_to_check: u32) -> bool {\n    return bool(vertex_attribute_layout & attribute_to_check);\n}\nfn vertex_attribute_offset(vertex_attribute_layout: u32, attribute_to_check: u32) -> i32 \n{\n    if(has_vertex_attribute(vertex_attribute_layout, attribute_to_check)) {\n        let mask = vertex_attribute_layout & (~attribute_to_check & (attribute_to_check - 1u));\n        return i32(countOneBits(mask));\n    }\n    return -1;\n}\nfn vertex_layout_stride(vertex_attribute_layout: u32) -> u32 \n{\n    return countOneBits(vertex_attribute_layout);\n}\n\n@group(0) @binding(0)\nvar<uniform> constant_data: ConstantData;\n@group(0) @binding(1)\nvar<storage, read> indices: Indices;\n@group(0) @binding(2)\nvar<storage, read> runtime_vertices: RuntimeVertices;\n@group(0) @binding(3)\nvar<storage, read> vertices_attributes: VerticesAttributes;\n@group(0) @binding(4)\nvar<storage, read> meshes: Meshes;\n@group(0) @binding(5)\nvar<storage, read> meshlets: Meshlets;\n@group(0) @binding(6)\nvar<storage, read> culling_result: array<u32>;\n\n@group(1) @binding(0)\nvar<storage, read> meshes_inverse_matrix: Matrices;\n@group(1) @binding(1)\nvar<storage, read> materials: Materials;\n@group(1) @binding(2)\nvar<storage, read> textures: Textures;\n@group(1) @binding(3)\nvar<storage, read> bhv: BHV;\n@group(1) @binding(4)\nvar<uniform> tlas_starting_index: u32;\n@group(1) @binding(5)\nvar<storage, read_write> rays: Rays;\n@group(1) @binding(6)\nvar render_target: texture_storage_2d<rgba8unorm, read_write>;\n\n@group(2) @binding(0)\nvar default_sampler: sampler;\n\n@group(2) @binding(1)\nvar texture_1: texture_2d_array<f32>;\n@group(2) @binding(2)\nvar texture_2: texture_2d_array<f32>;\n@group(2) @binding(3)\nvar texture_3: texture_2d_array<f32>;\n@group(2) @binding(4)\nvar texture_4: texture_2d_array<f32>;\n@group(2) @binding(5)\nvar texture_5: texture_2d_array<f32>;\n@group(2) @binding(6)\nvar texture_6: texture_2d_array<f32>;\n@group(2) @binding(7)\nvar texture_7: texture_2d_array<f32>;\n\n\nfn sample_texture(tex_coords_and_texture_index: vec3<f32>) -> vec4<f32> {\n    let texture_data_index = i32(tex_coords_and_texture_index.z);\n    var v = vec4<f32>(0.);\n    var tex_coords = vec3<f32>(0.0, 0.0, 0.0);\n    if (texture_data_index < 0) {\n        return v;\n    }\n    let texture = &textures.data[texture_data_index];\n    let atlas_index = (*texture).texture_index;\n    let layer_index = i32((*texture).layer_index);\n\n    tex_coords.x = ((*texture).area.x + tex_coords_and_texture_index.x * (*texture).area.z) / (*texture).total_width;\n    tex_coords.y = ((*texture).area.y + tex_coords_and_texture_index.y * (*texture).area.w) / (*texture).total_height;\n    tex_coords.z = f32(layer_index);\n\n    switch (atlas_index) {\n        case 0u: { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 1u: { v = textureSampleLevel(texture_2, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 2u: { v = textureSampleLevel(texture_3, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 3u: { v = textureSampleLevel(texture_4, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 4u: { v = textureSampleLevel(texture_5, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 5u: { v = textureSampleLevel(texture_6, default_sampler, tex_coords.xy, layer_index, 0.); }\n        case 6u: { v = textureSampleLevel(texture_7, default_sampler, tex_coords.xy, layer_index, 0.); }\n        default { v = textureSampleLevel(texture_1, default_sampler, tex_coords.xy, layer_index, 0.); }\n    };\n    return v;\n}\n\nfn extract_scale(m: mat4x4<f32>) -> vec3<f32> \n{\n    let s = mat3x3<f32>(m[0].xyz, m[1].xyz, m[2].xyz);\n    let sx = length(s[0]);\n    let sy = length(s[1]);\n    let det = determinant(s);\n    var sz = length(s[2]);\n    if (det < 0.) \n    {\n        sz = -sz;\n    }\n    return vec3<f32>(sx, sy, sz);\n}\n\nfn matrix_row(m: mat4x4<f32>, row: u32) -> vec4<f32> \n{\n    if (row == 1u) {\n        return vec4<f32>(m[0].y, m[1].y, m[2].y, m[3].y);\n    } else if (row == 2u) {\n        return vec4<f32>(m[0].z, m[1].z, m[2].z, m[3].z);\n    } else if (row == 3u) {\n        return vec4<f32>(m[0].w, m[1].w, m[2].w, m[3].w);\n    } else {        \n        return vec4<f32>(m[0].x, m[1].x, m[2].x, m[3].x);\n    }\n}\n\nfn normalize_plane(plane: vec4<f32>) -> vec4<f32> \n{\n    return (plane / length(plane.xyz));\n}\n\nfn rotate_vector(v: vec3<f32>, orientation: vec4<f32>) -> vec3<f32> \n{\n    return v + 2. * cross(orientation.xyz, cross(orientation.xyz, v) + orientation.w * v);\n}\n\nfn transform_vector(v: vec3<f32>, position: vec3<f32>, orientation: vec4<f32>, scale: vec3<f32>) -> vec3<f32> \n{\n    return rotate_vector(v, orientation) * scale + position;\n}\n\nstruct Derivatives {\n    dx: vec3<f32>,\n    dy: vec3<f32>,\n}\n\nfn compute_barycentrics(a: vec2<f32>, b: vec2<f32>, c: vec2<f32>, p: vec2<f32>) -> vec3<f32> {\n    let v0 = b - a;\n    let v1 = c - a;\n    let v2 = p - a;\n    \n    let d00 = dot(v0, v0);    \n    let d01 = dot(v0, v1);    \n    let d11 = dot(v1, v1);\n    let d20 = dot(v2, v0);\n    let d21 = dot(v2, v1);\n    \n    let inv_denom = 1. / (d00 * d11 - d01 * d01);    \n    let v = (d11 * d20 - d01 * d21) * inv_denom;    \n    let w = (d00 * d21 - d01 * d20) * inv_denom;    \n    let u = 1. - v - w;\n\n    return vec3 (u,v,w);\n}\n\n// Engel's barycentric coord partial derivs function. Follows equation from [Schied][Dachsbacher]\n// Computes the partial derivatives of point's barycentric coordinates from the projected screen space vertices\nfn compute_partial_derivatives(v0: vec2<f32>, v1: vec2<f32>, v2: vec2<f32>) -> Derivatives\n{\n    let d = 1. / determinant(mat2x2<f32>(v2-v1, v0-v1));\n    \n    var deriv: Derivatives;\n    deriv.dx = vec3<f32>(v1.y - v2.y, v2.y - v0.y, v0.y - v1.y) * d;\n    deriv.dy = vec3<f32>(v2.x - v1.x, v0.x - v2.x, v1.x - v0.x) * d;\n    return deriv;\n}\n\n// Interpolate 2D attributes using the partial derivatives and generates dx and dy for texture sampling.\nfn interpolate_2d_attribute(a0: vec2<f32>, a1: vec2<f32>, a2: vec2<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec2<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attribute_x = vec2<f32>(dot(deriv.dx, attr0), dot(deriv.dx, attr1));\n\tlet attribute_y = vec2<f32>(dot(deriv.dy, attr0), dot(deriv.dy, attr1));\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\n\n// Interpolate vertex attributes at point 'd' using the partial derivatives\nfn interpolate_3d_attribute(a0: vec3<f32>, a1: vec3<f32>, a2: vec3<f32>, deriv: Derivatives, delta: vec2<f32>) -> vec3<f32>\n{\n\tlet attr0 = vec3<f32>(a0.x, a1.x, a2.x);\n\tlet attr1 = vec3<f32>(a0.y, a1.y, a2.y);\n\tlet attr2 = vec3<f32>(a0.z, a1.z, a2.z);\n    let attributes = mat3x3<f32>(a0, a1, a2);\n\tlet attribute_x = attributes * deriv.dx;\n\tlet attribute_y = attributes * deriv.dy;\n\tlet attribute_s = a0;\n\t\n\treturn (attribute_s + delta.x * attribute_x + delta.y * attribute_y);\n}\nfn has_texture(material_id: u32, texture_type: u32) -> bool {\n    let material = &materials.data[material_id];\n    if ((*material).textures_indices[texture_type] >= 0) {\n        return true;\n    }\n    return false;\n}\n\nfn material_texture_index(material_id: u32, texture_type: u32) -> u32 {\n    let material = &materials.data[material_id];\n    let texture_index = (*material).textures_indices[texture_type];\n    if (texture_index < 0) {\n        return 0u;\n    }\n    return u32(texture_index);\n}\n\nfn material_texture_coord_set(material_id: u32, texture_type: u32) -> u32 {\n    let material = &materials.data[material_id];\n    return (*material).textures_coord_set[texture_type];\n}\n\nfn material_texture_uv(pixel_data: ptr<function, PixelData>, texture_type: u32) -> vec3<f32> {\n    let texture_coords_set = material_texture_coord_set((*pixel_data).material_id, texture_type);  \n    let texture_id = material_texture_index((*pixel_data).material_id, texture_type);\n    let uv = vec3<f32>((*pixel_data).uv_set[texture_coords_set], f32(texture_id));\n    return uv;\n} \n\nfn material_alpha(material_id: u32, vertex_color_alpha: f32) -> f32 {\n    let material = &materials.data[material_id];\n    \n    // NOTE: the spec mandates to ignore any alpha value in 'OPAQUE' mode\n    var alpha = 1.;\n    if ((*material).alpha_mode == MATERIAL_ALPHA_BLEND_OPAQUE) {\n        alpha = 1.;\n    } else if ((*material).alpha_mode == MATERIAL_ALPHA_BLEND_MASK) {\n        if (alpha >= (*material).alpha_cutoff) {\n            // NOTE: If rendering as masked alpha and >= the cutoff, render as fully opaque\n            alpha = 1.;\n        } else {\n            // NOTE: output_color.a < material.alpha_cutoff should not is not rendered\n            // NOTE: This and any other discards mean that early-z testing cannot be done!\n            alpha = -1.;\n        }\n    } else if ((*material).alpha_mode == MATERIAL_ALPHA_BLEND_BLEND) {\n        alpha = min((*material).base_color.a, vertex_color_alpha);\n    }\n    return alpha;\n}\n\nfn compute_normal(pixel_data: ptr<function, PixelData>) -> vec3<f32> {\n    var n = (*pixel_data).normal;\n    //if (has_texture((*pixel_data).material_id, TEXTURE_TYPE_NORMAL)) {    \n    //    let uv = material_texture_uv(pixel_data, TEXTURE_TYPE_NORMAL);\n    //    // get edge vectors of the pixel triangle \n    //    let dp1 = dpdx( (*pixel_data).world_pos ); \n    //    let dp2 = dpdy( (*pixel_data).world_pos ); \n    //    let duv1 = dpdx( uv.xy ); \n    //    let duv2 = dpdy( uv.xy );   \n    //    // solve the linear system \n    //    let dp2perp = cross( dp2, n ); \n    //    let dp1perp = cross( n, dp1 ); \n    //    let tangent = dp2perp * duv1.x + dp1perp * duv2.x; \n    //    let bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n    //    let t = normalize(tangent);\n    //    let b = normalize(bitangent); \n    //    let tbn = mat3x3<f32>(t, b, n);\n    //    let tn = sample_texture(uv);\n    //    n = tbn * (2. * tn.rgb - vec3<f32>(1.));\n    //    n = normalize(n);\n    //}\n    return n;\n}\n// Need constant_data, meshlets, meshes, indices, runtime_vertices, vertices_attributes\n\nfn visibility_to_gbuffer(visibility_id: u32, screen_uv: vec2<f32>) -> PixelData \n{     \n    var uv_set: array<vec2<f32>, 4>;\n    var normal = vec3<f32>(0.);\n    var color = vec4<f32>(1.);\n\n    let meshlet_id = (visibility_id >> 8u) - 1u; \n    let primitive_id = visibility_id & 255u;\n    \n    let meshlet = &meshlets.data[meshlet_id];\n    let index_offset = (*meshlet).indices_offset + (primitive_id * 3u);\n\n    let mesh_id = u32((*meshlet).mesh_index);\n    let mesh = &meshes.data[mesh_id];\n    let material_id = u32((*mesh).material_index);\n    let position_offset = (*mesh).vertices_position_offset;\n    let attributes_offset = (*mesh).vertices_attribute_offset;\n    let vertex_layout = (*mesh).vertices_attribute_layout;\n    let vertex_attribute_stride = vertex_layout_stride(vertex_layout);   \n    let offset_color = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_COLOR);\n    let offset_normal = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_NORMAL);\n    let offset_uv0 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV1);\n    let offset_uv1 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV2);\n    let offset_uv2 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV3);\n    let offset_uv3 = vertex_attribute_offset(vertex_layout, VERTEX_ATTRIBUTE_HAS_UV4); \n\n    let vert_indices = vec3<u32>(indices.data[index_offset], indices.data[index_offset + 1u], indices.data[index_offset + 2u]);\n    let pos_indices = vert_indices + vec3<u32>(position_offset, position_offset, position_offset);\n    let attr_indices = vec3<u32>(attributes_offset + vert_indices.x * vertex_attribute_stride, \n                                 attributes_offset + vert_indices.y * vertex_attribute_stride,\n                                 attributes_offset + vert_indices.z * vertex_attribute_stride);\n    \n    let v1 = runtime_vertices.data[pos_indices.x].world_pos;\n    let v2 = runtime_vertices.data[pos_indices.y].world_pos;\n    let v3 = runtime_vertices.data[pos_indices.z].world_pos;\n    \n    let mvp = constant_data.proj * constant_data.view;\n    var p1 = mvp * vec4<f32>(v1, 1.);\n    var p2 = mvp * vec4<f32>(v2, 1.);\n    var p3 = mvp * vec4<f32>(v3, 1.);\n\n    // Calculate the inverse of w, since it's going to be used several times\n    let one_over_w = 1. / vec3<f32>(p1.w, p2.w, p3.w);\n    p1 = (p1 * one_over_w.x + 1.) * 0.5;\n    p2 = (p2 * one_over_w.y + 1.) * 0.5;\n    p3 = (p3 * one_over_w.z + 1.) * 0.5;\n    \n    // Get delta vector that describes current screen point relative to vertex 0\n    var screen_pixel = screen_uv.xy;\n    screen_pixel.y = 1. - screen_pixel.y;\n    let delta = screen_pixel + -p1.xy;\n    let barycentrics = compute_barycentrics(p1.xy, p2.xy, p3.xy, screen_pixel);\n    let deriv = compute_partial_derivatives(p1.xy, p2.xy, p3.xy);   \n\n    let world_pos = barycentrics.x * v1 + barycentrics.y * v2 + barycentrics.z * v3; \n    let depth = barycentrics.x * p1.z + barycentrics.y * p2.z + barycentrics.z * p3.z;  \n\n    if (offset_color >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_color)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_color)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_color)];\n        let c1 = unpack_unorm_to_4_f32(a1);\n        let c2 = unpack_unorm_to_4_f32(a2);\n        let c3 = unpack_unorm_to_4_f32(a3);\n        color *= barycentrics.x * c1 + barycentrics.y * c2 + barycentrics.z * c3;    \n    }\n    if (offset_normal >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_normal)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_normal)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_normal)];\n        let n1 = unpack_snorm_to_3_f32(a1);\n        let n2 = unpack_snorm_to_3_f32(a2);\n        let n3 = unpack_snorm_to_3_f32(a3);\n        normal = barycentrics.x * n1 + barycentrics.y * n2 + barycentrics.z * n3;\n        normal = rotate_vector(normal, (*mesh).orientation); \n    }\n    if(offset_uv0 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv0)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv0)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv0)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[0] = interpolate_2d_attribute(uv1, uv2, uv3, deriv, delta);\n    }\n    if(offset_uv1 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv1)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv1)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv1)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[1] = interpolate_2d_attribute(uv1, uv2, uv3, deriv, delta);\n    }\n    if(offset_uv2 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv2)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv2)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv2)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[2] = interpolate_2d_attribute(uv1, uv2, uv3, deriv, delta);\n    }\n    if(offset_uv3 >= 0) {\n        let a1 = vertices_attributes.data[attr_indices.x + u32(offset_uv3)];\n        let a2 = vertices_attributes.data[attr_indices.y + u32(offset_uv3)];\n        let a3 = vertices_attributes.data[attr_indices.z + u32(offset_uv3)];\n        let uv1 = unpack2x16float(a1);\n        let uv2 = unpack2x16float(a2);\n        let uv3 = unpack2x16float(a3);\n        uv_set[3] = interpolate_2d_attribute(uv1, uv2, uv3, deriv, delta);\n    }    \n\n    return PixelData(world_pos, depth, normal, material_id, color, uv_set);\n}\nconst HIT_EPSILON: f32 = 0.0001;\nconst INVALID_NODE: i32 = -1;\n\nstruct Result {\n    distance: f32,\n    visibility_id: u32,\n}\n\nfn intersect_aabb(ray: ptr<function, Ray>, aabb_min: vec3<f32>, aabb_max: vec3<f32>) -> f32 \n{     \n    let r_min = (*ray).t_min;\n    let r_max = (*ray).t_max;\n    let inverse_dir = 1. / (*ray).direction;\n    let v_min = (aabb_min - (*ray).origin) * inverse_dir;\n    let v_max = (aabb_max - (*ray).origin) * inverse_dir;\n\n    let b_min = min(v_min, v_max);\n    let b_max = max(v_min, v_max);\n\n    let t_near = max(max(b_min.x, b_min.y), max(b_min.x, b_min.z));\n    let t_far = min(min(b_max.x, b_max.y), min(b_max.x, b_max.z));\n    \n    let r = select(t_near, r_max, t_near > t_far || t_far < 0.);\n    return r; \n}\n\nfn intersect_triangle(ray: ptr<function, Ray>, v0: vec3<f32>, v1: vec3<f32>, v2: vec3<f32>) -> f32\n{\n    let origin = (*ray).origin;\n    let dir = (*ray).direction;\n    let far = (*ray).t_max;\n\n    let e1 = v1 - v0;\n    let e2 = v2 - v0;\n\n    let p = cross(dir, e2);\n    let det = dot(e1, p);\n    \n    if (abs(det) < HIT_EPSILON) { return far; }\n\n    // Computes Barycentric coordinates.\n    let inv_det = 1. / det;\n    let t1 = origin - v0;    \n    let u = dot(t1, p) * inv_det;\n    if (u < 0. || u > 1.) { return far; }\n    \n    let q = cross(t1, e1);\n    let v = dot(dir, q) * inv_det;\n    if (v < 0. || u + v > 1.) { return far; }\n\n    let t2 = dot(e2, q) * inv_det;\n    return select(t2, far, t2 < 0.);\n}\n\nfn intersect_meshlet_primitive(ray: ptr<function, Ray>, position_offset: u32, meshlet_id: u32, index_offset: u32) -> f32 {\n    let vert_indices = vec3<u32>(indices.data[index_offset], indices.data[index_offset + 1u], indices.data[index_offset + 2u]);\n    let pos_indices = vert_indices + vec3<u32>(position_offset, position_offset, position_offset);\n        \n    return intersect_triangle(ray, runtime_vertices.data[pos_indices.x].world_pos, runtime_vertices.data[pos_indices.y].world_pos, runtime_vertices.data[pos_indices.z].world_pos);\n}\n\nfn intersect_meshlet(ray: ptr<function, Ray>, position_offset: u32, meshlet_id: u32, far_plane: f32) -> Result {\n    var nearest = far_plane;  \n    var visibility_id = 0u;\n      \n    let meshlet = &meshlets.data[meshlet_id];\n    let index_count = (*meshlet).indices_count;\n    let index_offset = (*meshlet).indices_offset;\n    for(var index = 0u; index < index_count; index = index + 3u)\n    {       \n        let hit = intersect_meshlet_primitive(ray, position_offset, meshlet_id, index_offset + index);\n        visibility_id = select(visibility_id, ((meshlet_id + 1u) << 8u) | index / 3u, hit < nearest);\n        nearest = min(nearest, hit);\n    }\n    return Result(nearest, visibility_id);\n}\n\nfn traverse_bhv_of_meshlets(world_ray: ptr<function, Ray>, local_ray: ptr<function, Ray>, mesh_id: u32, far_plane: f32) -> Result {\n    let mesh = &meshes.data[mesh_id];    \n    let position_offset = (*mesh).vertices_position_offset;\n    var blas_index = i32((*mesh).blas_index);    \n    let mesh_blas_index = blas_index;\n    var nearest = far_plane;  \n    var visibility_id = 0u;\n\n    while (blas_index >= 0)\n    { \n        let node = &bhv.data[u32(blas_index)];   \n        let intersection = intersect_aabb(local_ray, (*node).min, (*node).max);\n        if (intersection > nearest) {\n            blas_index = select((*node).miss, (*node).miss + mesh_blas_index, (*node).miss >= 0);\n            continue;\n        }\n        if ((*node).reference < 0) {\n            //inner node\n            blas_index = blas_index + 1;\n            continue;  \n        }\n        //leaf node\n        let meshlet_id = (*mesh).meshlets_offset + u32((*node).reference);   \n        \n        let index = meshlet_id / 32u;\n        let offset = meshlet_id - (index * 32u);\n        let bits = culling_result[index];\n        let is_meshlet_visible =  (bits & (1u << offset)) > 0u;   \n\n        if (!is_meshlet_visible) {\n            blas_index = select((*node).miss, (*node).miss + mesh_blas_index, (*node).miss >= 0);\n            continue;\n        }\n        let hit = intersect_meshlet(world_ray, position_offset, meshlet_id, nearest);\n        visibility_id = select(visibility_id, hit.visibility_id, hit.distance < nearest);\n        nearest = min(nearest, hit.distance);\n        blas_index = select((*node).miss, (*node).miss + mesh_blas_index, (*node).miss >= 0);\n    }\n    return Result(nearest, visibility_id);\n}\n\n\nconst MAX_PATH_BOUNCES: u32 = 8u;\nconst NUM_SAMPLES_PER_PIXEL: u32 = 1u;\nconst ADDITIONAL_EMISSIVE: f32 = 0.25;\n\n\nstruct RadianceData {\n    ray: Ray,\n    seed: vec2<u32>,\n    radiance: vec3<f32>, \n    throughput_weight: vec3<f32>, \n}\n\nfn sample_sphere(random_numbers: vec2<f32>) -> vec3<f32> {\n    let z = 2. * random_numbers.y - 1.;\n    let phi = 2. * PI * random_numbers.x;\n    let s = sqrt(1. - z * z);\n    let x = cos(phi) * s;\n    let y = sin(phi) * s;\n    return vec3<f32>(x, y, z);\n}\n\nfn sample_hemisphere(random_numbers: vec2<f32>, normal: vec3<f32>) -> vec3<f32> {\n    var direction = sample_sphere(random_numbers);\n    let d = dot(normal, direction);\n    return select(direction, direction - 2. * d * normal, d < 0.);\n}\n\n// Need constant_data, meshlets, meshes, indices, runtime_vertices, vertices_attributes\nfn compute_radiance_from_visibility(visibility_id: u32, screen_uv: vec2<f32>, data: RadianceData) -> RadianceData { \n    var pixel_data = visibility_to_gbuffer(visibility_id, screen_uv);\n    \n    let material = &materials.data[pixel_data.material_id];\n    var emissive_color = (*material).emissive_color + vec3<f32>(ADDITIONAL_EMISSIVE);\n    if (has_texture(pixel_data.material_id, TEXTURE_TYPE_EMISSIVE)) {\n        let t = material_texture_uv(&pixel_data, TEXTURE_TYPE_EMISSIVE);\n        emissive_color *= t.rgb;\n    }\n    pixel_data.color *= (*material).base_color;\n    if (has_texture(pixel_data.material_id, TEXTURE_TYPE_BASE_COLOR)) {  \n        let uv = material_texture_uv(&pixel_data, TEXTURE_TYPE_BASE_COLOR);\n        let texture_color = sample_texture(uv);\n        pixel_data.color *= texture_color * (*material).diffuse_color;\n    }\n    pixel_data.normal = compute_normal(&pixel_data);\n\n    let seed = get_random_numbers(data.seed);    \n    let rnd = vec2<f32>(seed) * 2.32830643654e-10;\n    let direction = sample_hemisphere(rnd, pixel_data.normal);\n\n    let rad = data.radiance + data.throughput_weight * emissive_color;\n    let d = dot(pixel_data.normal, direction);\n    let weight = data.throughput_weight * (pixel_data.color.rgb * 2. * d);\n    let origin = data.ray.origin + (data.ray.direction * data.ray.t_max) + direction * HIT_EPSILON;\n    let ray = Ray(origin, 0., direction, MAX_FLOAT);\n    return RadianceData(ray, seed, rad, weight);\n}\n\nfn compute_visibility_from_traversal(ray: ptr<function, Ray>) -> u32 \n{\n    var nearest = (*ray).t_max;  \n    var visibility_id = 0u;        \n    var tlas_index = 0;\n\n    while (tlas_index >= 0)\n    {\n        let node = &bhv.data[tlas_starting_index + u32(tlas_index)];    \n        let intersection = intersect_aabb(ray, (*node).min, (*node).max);\n        if (intersection > nearest) {\n            tlas_index = (*node).miss;\n            continue;\n        }\n        if ((*node).reference < 0) {\n            //inner node\n            tlas_index = tlas_index + 1;\n            continue;\n        }\n        //leaf node\n        let mesh_id = u32((*node).reference);\n        let inverse_matrix = &meshes_inverse_matrix.data[mesh_id];    \n        let transformed_origin = (*inverse_matrix) * vec4<f32>((*ray).origin, 1.);\n        let transformed_direction = (*inverse_matrix) * vec4<f32>((*ray).direction, 0.);\n        var transformed_ray = Ray(transformed_origin.xyz, (*ray).t_min, transformed_direction.xyz, (*ray).t_max);\n        let result = traverse_bhv_of_meshlets(ray, &transformed_ray, mesh_id, nearest);\n        visibility_id = select(visibility_id, result.visibility_id, result.distance < nearest);\n        nearest = min(nearest, result.distance);\n        tlas_index = (*node).miss;\n    } \n    (*ray).t_max = nearest;\n    return visibility_id;\n}\n\n\nfn execute_job(job_index: u32, pixel: vec2<f32>, dimensions: vec2<f32>) -> vec4<f32>  \n{    \n    var ray = rays.data[job_index];\n    var seed = vec2<u32>(pixel * dimensions) ^ vec2<u32>(constant_data.frame_index << 16u);\n    var uv_coords = 2. * (pixel / dimensions) - vec2<f32>(1., 1.);\n    uv_coords.y = -uv_coords.y;\n    var pixel_color = vec3<f32>(0.);\n    for (var sample = 0u; sample < NUM_SAMPLES_PER_PIXEL; sample++) {\n        var radiance_data = RadianceData(ray, seed, vec3<f32>(0.), vec3<f32>(1.));\n        for (var bounce = 0u; bounce < MAX_PATH_BOUNCES; bounce++) {\n            var r = radiance_data.ray;\n            let visibility_id = compute_visibility_from_traversal(&r);\n            if (visibility_id == 0u) {\n                break;\n            }\n            radiance_data.ray = r;\n            radiance_data = compute_radiance_from_visibility(visibility_id, uv_coords, radiance_data);\n            seed = radiance_data.seed;\n        }\n        pixel_color += radiance_data.radiance;\n    }\n    pixel_color /= f32(NUM_SAMPLES_PER_PIXEL);\n    return vec4<f32>(pixel_color, 1.);\n}\n\nvar<workgroup> jobs_count: atomic<i32>;\n\n@compute\n@workgroup_size(16, 16, 1)\nfn main(\n    @builtin(local_invocation_id) local_invocation_id: vec3<u32>, \n    @builtin(workgroup_id) workgroup_id: vec3<u32>\n) {\n    let max_jobs = 16 * 16;\n    let group = vec2<i32>(i32(workgroup_id.x), i32(workgroup_id.y));\n    let dimensions = vec2<i32>(textureDimensions(render_target));\n    atomicStore(&jobs_count, max_jobs);\n    \n    var job_index = 0;\n    while(job_index < max_jobs)\n    {\n        let pixel = vec2<i32>(group.x * 16 + job_index % 16, \n                              group.y * 16 + job_index / 16);\n        if (pixel.x >= dimensions.x || pixel.y >= dimensions.y) {\n            job_index = max_jobs - atomicSub(&jobs_count, 1);\n            continue;\n        }    \n        \n        let index = u32(pixel.y * dimensions.x + pixel.x);\n\n        var out_color = execute_job(index, vec2<f32>(pixel), vec2<f32>(dimensions));\n        if(constant_data.frame_index > 0u) {\n            var prev_value = textureLoad(render_target, pixel);\n            let weight = 1. / f32(constant_data.frame_index + 1u);\n            out_color = vec4<f32>((1. - weight) * prev_value.rgb + weight * out_color.rgb, 1.);\n        } \n        textureStore(render_target, pixel, out_color);\n        job_index = max_jobs - atomicSub(&jobs_count, 1);\n    }\n}\n"}